=== ./src/MediaType.cpp ===
#include "MediaType.hpp"

const std::string MediaType::TYPES_PATH = "./conf/media/types.csv";
t_mime_conf MediaType::ACCEPTED_TYPES;

void MediaType::load_types()
{
    std::ifstream in;
    in.exceptions(std::ifstream::badbit);

    try
    {
        in.open(TYPES_PATH.c_str());
        
        std::string line;
        std::getline(in, line); // Skip header

        while (!in.eof() && std::getline(in, line))
        {
            std::stringstream ss(line);
            ss.exceptions(std::ifstream::badbit);

            std::string type, subtype;
            std::getline(ss, type, ',');
            std::getline(ss, subtype, ',');
            wss::trim(type);
            wss::trim(subtype);

            std::vector<std::string> exts;
            std::string ext;
            while (!ss.eof() && std::getline(ss, ext, ','))
            {
                wss::trim(ext);
                exts.push_back(ext);
            }
            ACCEPTED_TYPES.push_back(std::make_pair(MediaType(type, subtype), exts));
        }
    } catch (const std::ifstream::failure& e)
    {
        Logger::getInstance().warning("Error reading MIME configuration. The server would not accept any Content-Types and 'native' POST requests");
        Logger::getInstance() << e.what();
        ACCEPTED_TYPES.clear();
        return ;
    }
}

bool ends_with(std::string const& filename, std::string const& ext) {
    return filename.size() >= ext.size() &&
           filename.compare(filename.size() - ext.size(), ext.size(), ext) == 0;
}

std::string MediaType::filename_to_type(std::string const & filename)
{
    for (t_mime_conf::iterator it = MediaType::ACCEPTED_TYPES.begin(); it != MediaType::ACCEPTED_TYPES.end(); it ++)
        for (std::vector<std::string>::iterator s = it->second.begin(); s != it->second.end(); s++)
        {
            // Logger::getInstance() << "Media type, testing " + filename + " with extension " + *s << std::endl;
            if (ends_with(filename, *s))  
                return it->first.type + "/" + it->first.subtype;
        }
    return "application/octet-stream";
}


MediaType::MediaType(){}

MediaType::MediaType(std::string type, std::string subtype):type(type), subtype(subtype){}

std::ostream & operator<<(std::ostream & os,  MediaType const & media)
{
    os << media.type << "/" << media.subtype << "; ";
    for (std::vector<std::pair<std::string, std::string> >::const_iterator params = media.parameters.begin(); params != media.parameters.end(); params ++)
    {
        os << params->first << "=" << params->second;
        if (params + 1 != media.parameters.end())
            os << "; ";
    }
    return os;
}

void MediaType::reset()
{
    type = "";
    subtype = "";
    parameters.clear();
}
=== ./src/ServerConfig.cpp ===
// ===== ServerConfig.cpp =====

#include "ServerConfig.hpp"
#include "StringUtil.hpp"
#include <algorithm>
#include <sstream>
#include <iostream>

ServerConfig::ServerConfig() 
    : root("/var/www/html")
    , autoindex(AINDX_DEF_OFF)
    , client_max_body_size(1048576)
    , allow_upload(false)
{
    index_files.push_back("index.html");
    index_files.push_back("index.htm");
    allow_methods.push_back("GET");
    allow_methods.push_back("POST");
    allow_methods.push_back("DELETE");
}

ServerConfig::ServerConfig(const ParsedServer& parsed) 
    : server_names(parsed.server_names)
    , root(parsed.root)
    , index_files(parsed.index_files)
    , error_pages(parsed.error_pages)
    , allow_methods(parsed.allow_methods)
    , autoindex(parsed.autoindex)
    , client_max_body_size(parseBodySize(parsed.client_max_body_size))
    , locations(parsed.locations)
    , allow_upload(false) // falta el allow_upload en ParsedServer
{
    if (index_files.empty()) {
        index_files.push_back("index.html");
        index_files.push_back("index.htm");
    }
    
    if (allow_methods.empty()) {
        allow_methods.push_back("GET");
        allow_methods.push_back("POST");
        allow_methods.push_back("DELETE");
    }
    
    if (root.empty()) {
        root = "/var/www/html";
    }

    if (locations.empty()) {
        Location default_location;
        default_location.setPath("/");
        default_location.setMatchType(Location::PREFIX); // QUESTION como va esto del setMatchType, contexto otrs tipos, donde se consume
        locations["/"] = default_location;
    }
}

ServerConfig::ServerConfig(const ServerConfig& other)
    : server_names(other.server_names)
    , root(other.root)
    , index_files(other.index_files)
    , error_pages(other.error_pages)
    , allow_methods(other.allow_methods)
    , autoindex(other.autoindex)
    , client_max_body_size(other.client_max_body_size)
    , locations(other.locations)
    , allow_upload(other.allow_upload)
{
}

ServerConfig& ServerConfig::operator=(const ServerConfig& other) {
    if (this != &other) {
        server_names = other.server_names;
        root = other.root;
        index_files = other.index_files;
        error_pages = other.error_pages;
        allow_methods = other.allow_methods;
        autoindex = other.autoindex;
        client_max_body_size = other.client_max_body_size;
        locations = other.locations;
    }
    return *this;
}

// matchesServerName
bool ServerConfig::matchesServerName(const std::string& hostname) const {
    if (server_names.empty()) {
        return true;
    }
    
    for (std::vector<std::string>::const_iterator it = server_names.begin(); 
         it != server_names.end(); ++it) {
        
        if (*it == "_") {
            return true;
        }
        
        if (wss::casecmp(*it, hostname)) {
            return true;
        }
    }
    
    return false;
}

// findLocation
Location* ServerConfig::findLocation(const std::string& path, bool resolve_index) const {
    std::map<std::string, Location>::const_iterator exact_it = locations.find(path);
    if (exact_it != locations.end() && exact_it->second.getMatchType() == Location::EXACT) {
        Location* exact_location = const_cast<Location*>(&exact_it->second);
        if (resolve_index && !path.empty() && path[path.length() - 1] == '/') {
            return resolveIndexAndRematch(path, exact_location);
        }
        return exact_location;
    }
    
    Location* best_match = NULL;
    size_t best_length = 0;
    
    for (std::map<std::string, Location>::const_iterator it = locations.begin();
         it != locations.end(); ++it) {
        
        const Location& location = it->second;
        if (location.getMatchType() == Location::PREFIX && location.matchesPath(path)) {
            size_t match_length = it->first.length();
            if (match_length > best_length) {
                best_match = const_cast<Location*>(&location);
                best_length = match_length;
            }
        }
    }
    
    if (best_match && resolve_index && !path.empty() && path[path.length() - 1] == '/') {
        return resolveIndexAndRematch(path, best_match);
    }
    
    return best_match;
}

// getErrorPage
std::string ServerConfig::getErrorPage(int error_code, const Location* location) const {
    
    if (location) {
        std::string loc_page = location->getErrorPage(error_code);
        if (!loc_page.empty())
            return loc_page;
    }

    std::map<int, std::string>::const_iterator it = error_pages.find(error_code);
    if (it != error_pages.end()) {
        return it->second;
    }

    return ""; // TODO implementar paginas default, reemplazar aqui
}

// isMethodAllowed
bool ServerConfig::isMethodAllowed(const std::string& method) const {
    if (allow_methods.empty()) {
        return true;
    }
    
    for (std::vector<std::string>::const_iterator it = allow_methods.begin();
         it != allow_methods.end(); ++it) {
        if (wss::casecmp(*it, method)) {
            return true;
        }
    }
    
    return false;
}

// getAllowMethods
const std::vector<std::string>& ServerConfig::getAllowMethods(const Location* location) const {
    if (location && !location->getMethods().empty()) {
        return location->getMethods();
    }
    
    return allow_methods;
}


// getAutoindex methods
bool ServerConfig::getAutoindex() const {
    return autoindex == AINDX_DEF_ON;
}

AutoIndexState ServerConfig::getAutoindex(const Location* location) const {
    if (location) {
        AutoIndexState loc_state = location->getAutoindex();
        
        if (loc_state == AINDX_LOC_ON || loc_state == AINDX_LOC_OFF) {
            return loc_state;
        }
    }
    
    return autoindex;
}

// getClientMaxBodySizeString
std::string ServerConfig::getClientMaxBodySizeString() const {
    if (client_max_body_size >= 1024 * 1024 * 1024) {
        return wss::i_to_dec(client_max_body_size / (1024 * 1024 * 1024)) + "G";
    } else if (client_max_body_size >= 1024 * 1024) {
        return wss::i_to_dec(client_max_body_size / (1024 * 1024)) + "M";
    } else if (client_max_body_size >= 1024) {
        return wss::i_to_dec(client_max_body_size / 1024) + "K";
    } else {
        return wss::i_to_dec(client_max_body_size);
    }
}

// getDebugInfo
std::string ServerConfig::getDebugInfo() const {
    std::stringstream ss;
    
    ss << "ServerConfig {\n";
    ss << "  server_names: [";
    for (size_t i = 0; i < server_names.size(); ++i) {
        ss << "\"" << server_names[i] << "\"";
        if (i < server_names.size() - 1) ss << ", ";
    }
    ss << "]\n";
    
    ss << "  root: \"" << root << "\"\n";
    ss << "  autoindex: " << (getAutoindex() ? "enabled" : "disabled") << "\n";
    ss << "  client_max_body_size: " << getClientMaxBodySizeString() << "\n";
    
    ss << "  index_files: [";
    for (size_t i = 0; i < index_files.size(); ++i) {
        ss << "\"" << index_files[i] << "\"";
        if (i < index_files.size() - 1) ss << ", ";
    }
    ss << "]\n";
    
    ss << "  allow_methods: [";
    for (size_t i = 0; i < allow_methods.size(); ++i) {
        ss << "\"" << allow_methods[i] << "\"";
        if (i < allow_methods.size() - 1) ss << ", ";
    }
    ss << "]\n";
    
    ss << "  locations: " << locations.size() << " locations\n";
    ss << "  error_pages: " << error_pages.size() << " custom pages\n";
    ss << "}";
    
    return ss.str();
}

size_t ServerConfig::parseBodySize(const std::string& size_str) const {
    static const size_t DEFAULT_SIZE = 1048576;  // 1MB default
    static const size_t MAX_SIZE = ~(static_cast<size_t>(0));  // MAX size_t

    if (size_str.empty()) {
        return DEFAULT_SIZE;
    }
    
    std::string number_part;
    std::string unit_part;
    size_t i;
    
    // EXTRACT NUMBER
    for (i = 0; i < size_str.length() && (std::isdigit(size_str[i]) || size_str[i] == '.'); ++i) {
        number_part += size_str[i];
    }
    
    // EXTRACT UNIT
    while (i < size_str.length()) {
        unit_part += std::toupper(size_str[i]);
        ++i;
    }
    
    if (number_part.empty()) {
        return DEFAULT_SIZE;
    }
    
    size_t base_size = static_cast<size_t>(std::atoll(number_part.c_str()));
    
    // PROTECT FROM VALUE = 0
    if (base_size == 0) {
        return DEFAULT_SIZE;
    }
    
    // UNIT CONVERTION
    if (unit_part.empty() || unit_part == "B" || unit_part == "BYTES") {
        return base_size;
    } else if (unit_part == "K" || unit_part == "KB" || unit_part == "KIB") {
        if (base_size > MAX_SIZE / 1024) return MAX_SIZE;  // PROTECT OVERFLOW
        return base_size * 1024;
    } else if (unit_part == "M" || unit_part == "MB" || unit_part == "MIB") {
        if (base_size > MAX_SIZE / (1024 * 1024)) return MAX_SIZE;  // PROTECT OVERFLOW
        return base_size * 1024 * 1024;
    } else if (unit_part == "G" || unit_part == "GB" || unit_part == "GIB") {
        if (base_size > MAX_SIZE / (1024 * 1024 * 1024)) return MAX_SIZE;  // PROTECT OVERFLOW
        return base_size * 1024 * 1024 * 1024;
    }
    
    return DEFAULT_SIZE;  // UNKNOWN UNIT
}

Location* ServerConfig::resolveIndexAndRematch(const std::string& path, Location* original_location) const {
    for (std::vector<std::string>::const_iterator it = index_files.begin();
         it != index_files.end(); ++it) {
        
        std::string index_path = path + *it;
        
        Location* new_location = findLocation(index_path, false);
        if (new_location && new_location != original_location) {
            return new_location;
        }
    }
    
    return original_location;
}

std::ostream& operator<<(std::ostream& os, const ServerConfig& config) {
    os << config.getDebugInfo();
    return os;
}

// para debug
std::string ServerConfig::getServerNamesString() const {
    if (server_names.empty()) {
        return "_";
    }
    std::string result;
    for (size_t i = 0; i < server_names.size(); ++i) {
        result += server_names[i];
        if (i < server_names.size() - 1) {
            result += ", ";
        }
    }
    return result;
}

bool ServerConfig::isDefaultServer() const {
    return server_names.empty() || 
            (server_names.size() == 1 && server_names[0] == "_");
}
=== ./src/Listen.cpp ===
#include "../inc/Listen.hpp"
#include <sstream>

Listen::Listen(const std::string& host, const int port, bool is_default)
    : host(host), port(port), is_default(is_default) {}

Listen::~Listen() {}

bool Listen::operator==(const Listen& other) const {
    return (host == other.host && port == other.port && is_default == other.is_default);
}

bool Listen::operator<(const Listen& other) const {
    if (host < other.host)
        return true;
    if (host > other.host)
        return false;
    if (port < other.port)
        return true;
    return (port < other.port);
}

std::string Listen::to_string() const {
    std::ostringstream oss;
    oss << host << ":" << port;
    if (is_default) oss << " [default_server]";
    return oss.str();
}

std::ostream& operator<<(std::ostream& os, const Listen& pl) {
    os << pl.host << ":" << pl.port;
    return os;
}

=== ./src/Parsed.cpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Parsed.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/30 13:58:20 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 20:18:01 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ConfigInheritance.hpp"
#include "Parsed.hpp"
#include "Utils.hpp"
#include "ServerValidator.hpp"
#include "VirtualServersManager.hpp"

// Temporary color macros to fix compilation
#define RED        "\033[1;91m"
#define GREEN      "\033[1;92m"
#define YELLOW     "\033[1;93m"
#define BLUE       "\033[1;94m"
#define RESET      "\033[0m"

ParsedServer::ParsedServer(
    const Listen& listen,
    const std::vector<std::string>& serverNames,
    const std::string& root,
    const std::vector<std::string>& indexFiles,
    const std::map<int, std::string>& errorPages,
	const std::vector<std::string>& methods,
    const std::map<std::string, Location>& locations
)
  : server_names(serverNames)
  , root(root)
  , index_files(indexFiles)
  , error_pages(errorPages)
  , allow_methods(methods)
  , autoindex(AINDX_DEF_OFF)
  , locations(locations)
{
    listens.push_back(listen);
}

ParsedServer::~ParsedServer() {}

std::vector<std::string> tokenize(const std::string& content)
{
	std::vector<std::string> tokens;
	std::string current;
	bool is_comment = false;

	for (size_t i = 0; i < content.length(); ++i)
	{
		char c = content[i];

		if (c == '#')
		{
			is_comment = true;
			continue;
		}

		if (is_comment)
		{
			if (c == '\n')
			{
				is_comment = false;
			}
			continue;
		}

		if (isspace(c))
		{
			if (!current.empty())
			{
				tokens.push_back(current);
				current.clear();
			}
		}
		else if (c == '{' || c == '}' || c == ';')
		{
			if (!current.empty())
			{
				tokens.push_back(current);
				current.clear();
			}
			tokens.push_back(std::string(1, c));
		}
		else
		{
			current += c;
		}
	}
	if (!current.empty())
	{
		tokens.push_back(current);
	}
	return (tokens);
}

size_t expect(const std::vector<std::string>& tokens, size_t i, const std::string& expected)
{
	if (tokens[i] != expected)
	{
		throw std::runtime_error("Expected: " + expected + ", got: " + tokens[i]);
	}

	return (i + 1);
}

/*
TODO
En parseLocation
error_page
debería validar que los archivos existan al parsear el path

*/
Location parseLocation(const std::vector<std::string> &tokens, size_t &i)
{
	Location loc;
	
	if (tokens[i] == "=") {
		loc.setMatchType(Location::EXACT);
		++i;
		loc.setPath(tokens[i]);
		++i;
	}
	else if (tokens[i] == "~" || tokens[i] == "~*") {
		throw std::runtime_error("Invalid regex location");
	}
	else {
		loc.setPath(tokens[i]);
		loc.setMatchType(Location::PREFIX);
		++i;
	}

	i = expect(tokens, i, "{");
	while (i < tokens.size() && tokens[i] != "}")
	{
		std::string key = tokens[i++];
		if (key == "location")
        {
            throw std::runtime_error("Locations inside location are not supported.");
		}
		else if (key == "allow_methods")
		{
			std::vector<std::string> methods;
			while (i < tokens.size() && tokens[i] != ";")
				methods.push_back(tokens[i++]);
			if (i < tokens.size() && tokens[i] == ";") ++i;
			loc.setMethods(methods);
		}
		else if (key == "root")
		{
			if (i < tokens.size()) loc.setRoot(tokens[i++]);
		}
		else if (key == "index")
		{
			if (i < tokens.size()) loc.setIndex(tokens[i++]);
		}
		else if (key == "autoindex")
		{
			std::string autoindex_value = tokens[i++];
			if (autoindex_value == "true" || autoindex_value == "on")
				loc.setAutoindex(AINDX_LOC_ON);
			else if (autoindex_value == "false" || autoindex_value == "off")
				loc.setAutoindex(AINDX_LOC_OFF);
			else {
				loc.setAutoindex(AINDX_LOC_OFF);
				std::cout << "Invalid argument for 'autoindex' directive. Setting default = false." << std::endl;
			}
			if (i < tokens.size() && tokens[i] == ";") ++i;
		}
		else if (key == "redirect") 
		{
            if (i < tokens.size()) loc.setRedirect(tokens[i++]);
        }
        else if (key == "cgi_extension")
		{
            if (i < tokens.size()) loc.setCgixtension(tokens[i++]);
        }
        else if (key == "allow_upload")
		{
            if (i < tokens.size()) {
                std::string value = tokens[i++];
                loc.setAllowUpload(value == "on" || value == "true");
            }
        }
		else if (key == "error_page")
		{
			std::vector<int> codes;
			while (i < tokens.size() && tokens[i] != ";" && isdigit(tokens[i][0]))
				codes.push_back(to_int(tokens[i++]));
			
			if (i < tokens.size() && tokens[i] != ";") {
				std::string error_page_path = tokens[i++];
				for (size_t j = 0; j < codes.size(); ++j) {
					loc.setErrorPage(codes[j], error_page_path); 
				}
			}
			if (i < tokens.size() && tokens[i] == ";") ++i;
		}
        else
		{
            if (i < tokens.size() && tokens[i] == ";") ++i;
        }
	}
	if (i < tokens.size() && tokens[i] == "}") ++i;


// debug

	Logger::getInstance().info("=== PARSED LOCATION DEBUG ===");
	Logger::getInstance().info("  path: '" + loc.getPath() + "'");
	Logger::getInstance().info("  match_type: " + std::string(loc.getMatchType() == Location::EXACT ? "EXACT" : "PREFIX"));
	Logger::getInstance().info("  methods count: " + wss::i_to_dec(loc.getMethods().size()));
	for (size_t j = 0; j < loc.getMethods().size(); ++j) {
		Logger::getInstance().info("    method[" + wss::i_to_dec(j) + "]: " + loc.getMethods()[j]);
	}
	Logger::getInstance().info("  root: '" + loc.getRoot() + "'");
	Logger::getInstance().info("  index: '" + loc.getIndex() + "'");
	Logger::getInstance().info("  autoindex: " + wss::i_to_dec(static_cast<int>(loc.getAutoindex())));
	Logger::getInstance().info("  redirect: '" + loc.getRedirect() + "'");
	Logger::getInstance().info("  cgi_extension: '" + loc.getCgiExtension() + "'");
	Logger::getInstance().info("  allow_upload: " + std::string(loc.getAllowUpload() ? "TRUE" : "FALSE"));
	Logger::getInstance().info("=== END PARSED LOCATION DEBUG ===");

//end debug

	return loc;
}

int to_int(const std::string& s)
{
	std::stringstream ss(s);
	int result;
	ss >> result;

	return (result);
}

Listen parse_listen(const std::vector<std::string>& tokens)
{
	Listen ld;

	for (size_t i = 0; i < tokens.size(); ++i)
	{
		const std::string& token = tokens[i];
		if (token == "default_server")
		{
			printParsingMessage(DEFAULT_SERVER);
		}
		else
		{
			size_t brace_open = token.find('[');
			size_t brace_close = token.find(']');
			size_t point = token.find('.');
			size_t colon = token.find(':');
			if (brace_open != std::string::npos)
			{
				if (brace_close == std::string::npos)
					throw std::runtime_error("Unclosed brackets in listen directive");
				throw std::runtime_error("IPv6 addresses are not allowed: " + token);
			}
			else if (colon != std::string::npos)
			{
				if (token.substr(0, colon) == "localhost")
				{
					printParsingMessage(LOCAL_HOST);
                    ld.host = getLoopbackAddress();
					ld.port = to_int(token.substr(colon + 1));
				}
                else if (token.substr(0, colon).size() == 1 && token.substr(0, colon)[0] == '*')
				{
					printParsingMessage(ASTERIKS_HOST);
					ld.port = to_int(token.substr(colon + 1));
				}
				else 
				{
					ld.host = token.substr(0, colon);
					ld.port = to_int(token.substr(colon + 1));
				}
			} 
			else if (std::isdigit(token[0]) && point == std::string::npos)
			{
				ld.port = to_int(token);
			}
			else
			{
				if (token == "localhost") {
					ld.host = getLoopbackAddress(); }
				else if (token[0] != '*')
					ld.host = token;
			}
		}
	}

	return (ld);
}

ParsedServer parseServer(const std::vector<std::string> &tokens, size_t &i)
{
	ParsedServer server;

	i = expect(tokens, i, "server");
	i = expect(tokens, i, "{");
	while (tokens[i] != "}")
	{
		std::string key = tokens[i++];
		if (key == "listen")
		{
			std::vector<std::string> listen_tokens;
			while (tokens[i] != ";")
			{
				listen_tokens.push_back(tokens[i++]);
			}
			++i;
			Listen ld = parse_listen(listen_tokens);
			server.listens.push_back(ld);
		}
		else if (key == "server_name")
		{
			while (tokens[i] != ";") server.server_names.push_back(tokens[i++]);
		}
		else if (key == "root")
			server.root = tokens[i++];
		else if (key == "index")
		{
			while (tokens[i] != ";")
				server.index_files.push_back(tokens[i++]);
		}
		else if (key == "error_page")
		{
			std::vector<int>codes;
			while (isdigit(tokens[i][0]))
				codes.push_back(to_int(tokens[i++]));
			
			std::string error_page_path = tokens[i++];
			for (size_t j = 0; j < codes.size(); ++j)
			{
				server.error_pages[codes[j]] = error_page_path;
			}
		}
		else if (key == "allow_methods")
		{
			while (tokens[i] != ";")
				server.allow_methods.push_back(tokens[i++]);
        }
		else if (key == "autoindex")
		{
			std::string autoindex_value = tokens[i++];
			if (autoindex_value == "true" || autoindex_value == "on")
				server.autoindex = AINDX_SERV_ON;
			else if (autoindex_value == "false" || autoindex_value == "off")
				server.autoindex = AINDX_SERV_OFF;
			else {
				server.autoindex = AINDX_DEF_OFF;
				std::cout << "Invalid argument for 'autoindex' directive. Setting default = false." << std::endl;
			}
		}
		else if (key == "client_max_body_size")
			server.client_max_body_size = tokens[i++];
		else if (key == "location")
		{
			Location loc = parseLocation(tokens, i);
			server.locations[loc.getPath()] = loc;
		}
		if (i < tokens.size() && tokens[i] == ";") ++i;
	}
	++i;

	applyAutoindex(server);
	applyAllowMethods(server);

	return (server);
}

/*

Posibles mejoras de robustez de la validacion en server validator
 Códigos de error HTTP válidos (100-599)
 Valores de autoindex válidos (on/off/true/false)
 Tamaños de client_max_body_size válidos
 Métodos HTTP válidos en allow_methods
 Rutas de archivos válidas en root, index, error_page
 Sintaxis de locations válida
 Sintaxis de listen válida (puertos 1-65535)

*/

std::vector<ParsedServer> parseConfig(const std::vector<std::string> &tokens)
{
	std::vector<ParsedServer> servers;

	size_t i = 0;
	while (i < tokens.size())
	{
		if (tokens[i] == "server")
		{
			servers.push_back(parseServer(tokens, i));
		}
		else
		{
			throw std::runtime_error("Unknown directive outside server block: " + tokens[i]);
		}
	}

	return (servers);
}

// SIMPLE ARBOL DE CONDICIONES QUE EVALUA ARGUMENTOS, PARA SACARLO DEL FLUJO DEL MAIN
int parseProcess(int argc, char **argv, ParsedServers& parsedConfig) {

    if (argc > 2) {
        std::cerr << std::endl << RED << "ERROR: " << RESET <<
        "This program start with arguments ---> " << YELLOW <<
        "./webserver [filename]" << RESET << std::endl << std::endl;
        return (1);
    }

    try {
        std::string configFile;
        std::string successMessage;
        if (argc == 2) {
			if (checkFile(argv[1]) == -1)
				return (1);
            configFile = argv[1];
            successMessage = "Success: starting server with custom config";
        } else {
            configFile = "conf/default.conf";
            successMessage = "Success: starting server with default config";
        }
        
        std::ifstream file(configFile.c_str());
        if (!file.is_open()) {
            std::cerr << RED << "ERROR: " << RESET <<
            "Cannot open config file: " << configFile << std::endl;
            return (1);
        }
        
        std::stringstream buffer;
        buffer << file.rdbuf();
        std::string content = buffer.str();
        file.close();
        
        std::vector<std::string> tokens = tokenize(content);

		parsedConfig = parseConfig(tokens);


		for (size_t i = 0; i < parsedConfig.size(); ++i)
		{
			printServerConfig(parsedConfig[i]);
		}

        ServerValidator::validate(parsedConfig);

        std::cout << BLUE << successMessage << RESET << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << RED << "PARSING ERROR: " << RESET << e.what() << std::endl;
        return (1);
    }
    
    return (0);
}



=== ./src/File.cpp ===
#include "File.hpp"

File::File()
{
    fd = -1;
    _dir = NULL;
    filetype = NONE;
}

File::File(std::string const & path, int mode)
:fd(-1), filetype(NONE), _dir(NULL)
{
    open_file(path, mode, 0);
}

void File::open(std::string const & path, int mode, int f)
{
    destroy_current();
    open_file(path, mode, f);
}

void File::close(){destroy_current();}

File::~File()
{
    destroy_current();
}

off_t File::size() const
{
    if (filetype != REGULAR)
        CODE_ERR(std::string("Unexpectedly asking size of a non-regular file"));
    return _statbuf.st_size;
}

time_t File::last_modified() const
{
    if (filetype == NONE)
        CODE_ERR(std::string("Unexpectedly asking last-modified of an invalid or unintiialized state"));
    return _statbuf.st_mtime;
}

File::descriptor_status File::get_status() const
{
    // if (filetype == NONE)
    //     CODE_ERR(std::string("Unexpectedly asking status of an invalid or unintiialized state"));
    return status;
}

struct dirent * File::dir_next()
{
    return readdir(_dir);
}

void File::destroy_current()
{
    if (fd > -1)
    {
        ::close(fd);
        fd = -1;
    }
    if (_dir)
    {
        closedir(_dir);
        _dir = NULL;
    }
    filetype = NONE;
}

void File::open_file(std::string const & path, int mode, int f)
{
    status = OK;
    fd = ::open(path.c_str(), mode, f);
    if (fd == -1)
    {
        handle_error();
        return ;
    }
    if (fstat(fd, &_statbuf) == -1)
    {
        handle_error();
        return ;
    }
    if (S_ISREG(_statbuf.st_mode) || S_ISLNK(_statbuf.st_mode))
    {
        filetype = REGULAR;
    }
    else if (S_ISDIR(_statbuf.st_mode))
    {
        filetype = DIRECTORY;
        _dir = fdopendir(fd);
        if (!_dir)
        {
            handle_error();
            return ;
        }
    }
    else
    {
        status = RAREFILE;
        return ;
    }
}
    
void File::handle_error()
{
    switch (errno)
    {
        case ENOENT: status = NOTFOUND; return;
        case EPERM:
        case EROFS:
        case EFAULT:
        case EACCES: status = NOPERM; return ;
        case EINVAL: status = BADFILENAME; return ;
        default: status = ERROR; return ;
    }
    destroy_current();
}


=== ./src/response/ResponseManager.cpp ===
#include "ResponseManager.hpp"
#include "ServerConfig.hpp"

// I UNDERSTAND THIS IS FOR TESTING ONLY... POSSIBLE MEMORY LEAK IF NOT REMOVED
// Location * lc = new Location();

/*
    Remember status with content, should put C.L 0 or send error page.
*/

ResponseManager::ResponseManager(HTTPRequest & request, HTTPError & error, SysBufferFactory::sys_buffer_type type, int fd)
    : _request(request)
    , _error(error)
    , _status(WAITING_REQUEST)
    , _server(NULL)
    , _location(NULL)
{
    _sys_buffer = SysBufferFactory::get_buffer(type, fd);

    /*
    // TESTING LOCATION CONFIG.
    lc->setPath("/def/");
    lc->setRoot("/home/kevin/42/webserv/test-nginx/www");

    std::vector<std::string> m;
    m.push_back("GET");
    m.push_back("POST");
    m.push_back("DELETE");
    lc->setMethods(m);

    this->_location = lc;
    this->_server = NULL;  // INITIALIZE SERVER POINTER TO NULL
    */
}

ResponseManager::~ResponseManager(){delete _sys_buffer;}

void ResponseManager::set_virtual_server(ServerConfig const * config){_server = config;}  // UPDATED: Server -> ServerConfig

void ResponseManager::set_location(Location const * location){_location = location;}

void ResponseManager::reset() {
    new_response();
}

ActiveFileDescriptor ResponseManager::get_active_file_descriptor()
{
    switch (_status)
    {
        case WAITING_REQUEST:
        case ERROR:
        case DONE:
            CODE_ERR("Trying to get active file descriptor from an invalid status");
        case READING_FILE: return ActiveFileDescriptor(_file.fd, EPOLLIN);
        case WRITING_FILE: return ActiveFileDescriptor(_file.fd, EPOLLOUT);
        case WRITING_RESPONSE: return ActiveFileDescriptor(_sys_buffer->_fd, EPOLLOUT);
        default: CODE_ERR("Trying to get active file descriptor from an invalid status");
    }
}

/*
    Called once request is done
*/
void ResponseManager::generate_response()
{
    Logger::getInstance() << "Generating response for client " + wss::i_to_dec((ssize_t) _sys_buffer->_fd) << std::endl;;

    switch (::status::status_type(_error.status()))
    {
        case STYPE_IMMEDIATE_RESPONSE: generate_status_response(); break;
        case STYPE_GENERATE_RESPONSE:
            if (!validate_method())
                return generate_status_response();
            switch (_request.method)
            {
                case GET: generate_get_response(); break ;
                case POST: generate_post_response(); break ;
                case DELETE: generate_delete_response(); break ;
                default: CODE_ERR("Not implemented");
            }
    }
}

bool ResponseManager::validate_method()
{
    std::vector<HTTPMethod> methods = get_allowed_methods();
    for (std::vector<HTTPMethod>::iterator it = methods.begin(); it != methods.end(); it ++)
        if (*it == _request.method)
            return true;
    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": method not allowed " + method::method_to_str(_request.method) << std::endl;
    _error.set("Method not allowed", METHOD_NOT_ALLOWED);
    return false;
}

void ResponseManager::new_response()
{
    _buffer.clear();
    _server = NULL;
    _location = NULL;
    _status = WAITING_REQUEST;
}

void ResponseManager::generate_get_response()
{
    std::string final_path = get_host_path();

    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": Generating GET response. File: " + final_path << std::endl;

    _file.open(final_path, O_RDONLY);

    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": Status at opepning file: " + wss::ui_to_dec( _file.get_status()) + " Type. " + wss::ui_to_dec( _file.filetype) << std::endl;;

    switch (_file.get_status())
    {
        case File::OK: break;
        case File::NOTFOUND: _error.set("File not found", NOT_FOUND); return generate_status_response();
        case File::NOPERM:  _error.set("No access to this file", FORBIDDEN); return generate_status_response();
        case File::BADFILENAME: _error.set("File's basename is invalid", BAD_REQUEST); return generate_status_response();
        case File::RAREFILE: _error.set("File type is not operational", FORBIDDEN); return generate_status_response();
        case File::ERROR: _error.set("Error reading file", INTERNAL_SERVER_ERROR); return generate_status_response();
    }
    switch (_file.filetype)
    {
        case File::REGULAR: prepare_file_reading(); break;
        case File::DIRECTORY: read_directory(); break;
        case File::NONE: _error.set("Rare file type", FORBIDDEN); return generate_status_response();
    }
}

void ResponseManager::generate_post_response()
{
    std::string final_path = get_host_path();
    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": Procesing POST. File: " + final_path << std::endl;

    _file.open(final_path, O_WRONLY | O_CREAT | O_TRUNC, 0777);
    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": Status at opepning file: " + wss::ui_to_dec( _file.get_status()) + " Type. " + wss::ui_to_dec( _file.filetype) << std::endl;;

    switch (_file.get_status())
    {
        case File::OK: break;
        case File::NOTFOUND: _error.set("File not found", NOT_FOUND); return generate_status_response();
        case File::NOPERM:  _error.set("No access to this file", FORBIDDEN); return generate_status_response();
        case File::BADFILENAME: _error.set("File's basename is invalid", BAD_REQUEST); return generate_status_response();
        case File::RAREFILE: _error.set("File type is not operational", FORBIDDEN); return generate_status_response();
        case File::ERROR: _error.set("Error reading file", INTERNAL_SERVER_ERROR); return generate_status_response();
    }
    switch (_file.filetype)
    {
        case File::REGULAR: break;
        case File::DIRECTORY: _error.set("Can't overwrite a directory", FORBIDDEN); return generate_status_response();
        case File::NONE: _error.set("Rare file type", FORBIDDEN); return generate_status_response();
    }

    _wr_file_it = _request.body.content.begin();
    _status = WRITING_FILE;
};

void ResponseManager::generate_delete_response()
{
    std::string final_path = get_host_path();
    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ": Procesing DELETE. File: " + final_path << std::endl;
    
    _file.open(final_path, O_RDONLY);

    switch (_file.get_status())
    {
        case File::OK: break;
        case File::NOTFOUND: _error.set("File not found", NOT_FOUND); return generate_status_response();
        case File::NOPERM:  _error.set("No access to this file", FORBIDDEN); return generate_status_response();
        case File::BADFILENAME: _error.set("File's basename is invalid", BAD_REQUEST); return generate_status_response();
        case File::RAREFILE: _error.set("File type is not operational", FORBIDDEN); return generate_status_response();
        case File::ERROR: _error.set("Error reading file", INTERNAL_SERVER_ERROR); return generate_status_response();
    }
    switch (_file.filetype)
    {
        case File::REGULAR: break;
        case File::DIRECTORY: _error.set("Can't delete a directory", FORBIDDEN); return generate_status_response();
        case File::NONE: _error.set("Rare file type", FORBIDDEN); return generate_status_response();
    }

    _file.close();
    std::remove(final_path.c_str());
};

void ResponseManager::prepare_file_reading()
{
    std::string final_path = get_host_path();

    _buffer.put_protocol("HTTP/1.1");
    _buffer.put_status(_error);
    _buffer.put_header("Server", "Webserv");
    _buffer.put_header_time("Date", time(NULL));
    _buffer.put_header_time("Last-Modified", _file.last_modified());
    _buffer.put_header_number("Content-Length", _file.size());
    _buffer.put_header("Content-Type", MediaType::filename_to_type(final_path));
    _buffer.put_new_line();
    _status = READING_FILE;
}

/*
    Each iteration reads from a file and puts the result in the internal buffer.
    When the file's end has been reached, it sets the flag to response.

    If there's a problem reading the file, sets internal error status (File should exists and be ok, cheked before). Wipes the
    current headers, and returns to response loop.
*/
void ResponseManager::read_file()
{
    ssize_t bytes_read = _buffer.write_from_fd(_file.fd, ResponseManager::_READ_FILE_BUFFER_SIZE);
    if (bytes_read < 0)
    {
        _buffer.clear();
        _status = WAITING_REQUEST ;
        _error.set("Error reading file", INTERNAL_SERVER_ERROR);
        return generate_status_response();
    }
    if (bytes_read == 0)
    {
        Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ". File read. Full planned response: " + std::string(_buffer.itbegin(), _buffer.itend()) << std::endl;
        _status = WRITING_RESPONSE;
    }
}

void ResponseManager::write_file()
{
    size_t write_qty = ResponseManager::_WRITE_FILE_BUFFER_SIZE;
    // Just writes from the body's pointer to the end or write limit
    ssize_t bytes_writen = write(_file.fd, &(*_wr_file_it), std::min(write_qty, (size_t) std::distance(_wr_file_it, _request.body.content.end())));

    if (bytes_writen < 0)
    {
        _status = WAITING_REQUEST ;
        _error.set("Error writing file", INTERNAL_SERVER_ERROR);
        return generate_status_response();
    }

    // Advance the content pointer
    _wr_file_it += bytes_writen;
    if (_wr_file_it == _request.body.content.end())
    {
        _buffer.put_protocol("HTTP/1.1");
        _buffer.put_status(_error);
        _buffer.put_header("Server", "Webserv");
        _buffer.put_header_time("Date", time(NULL));
        Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ". File writen. Full planned response: \n" + std::string(_buffer.itbegin(), _buffer.itend()) << std::endl;
        _status = WRITING_RESPONSE;
    }
}

void ResponseManager::read_directory()
{
    _buffer.put_protocol("HTTP/1.1");
    _buffer.put_status(_error);
    _buffer.put_header("Server", "Webserv");
    _buffer.put_header_time("Date", time(NULL));
    _buffer.put_header_time("Last-Modified", _file.last_modified());
    _buffer.put_header("Content-Type", "text/html");

    // Check if we have a valid server configuration
    if (!_server) {
        _error.set("Server configuration not found", INTERNAL_SERVER_ERROR);
        return generate_status_response();
    }

    // USING LOCATION->getAutoindex(), then SERVER, WITH PROTECTION FOR !SERVER
    bool autoindex_enabled = false;
    if (_server) {
        AutoIndexState state = _server->getAutoindex(_location);
        autoindex_enabled = (state == AINDX_LOC_ON
                            || state == AINDX_SERV_ON
                            || state == AINDX_DEF_ON);
    }

    if (!autoindex_enabled) {
        _error.set("Directory listing is forbidden", FORBIDDEN);
        return generate_status_response();
    }

    std::string final_path = get_host_path();
    std::string dir_prefix = "";
    if (!_request.uri.path.empty() && _request.uri.path[_request.uri.path.size() - 1] != '/')
        dir_prefix = _request.uri.path + "/";
    else
        dir_prefix = _request.uri.path;
    
    std::string dirs;

    dirs += "<!DOCTYPE html><html><body>";
    while (struct dirent * dir = _file.dir_next())
        if (dir->d_type == DT_DIR)
            dirs += "<a href=\"" + dir_prefix + dir->d_name + "\">" + dir->d_name + "</a><hr>";
    dirs += "</html></body>";

    _buffer.put_header("Content-Length", wss::i_to_dec(dirs.size()));
    _buffer.put_new_line();
    _buffer.put_body(dirs);

    Logger::getInstance() << wss::ui_to_dec( _sys_buffer->_fd) + ". Full planned response: " + std::string(_buffer.itbegin(), _buffer.itend()) << std::endl;
    _status = WRITING_RESPONSE;
}

// TODO como manejar la jerarquia de rutas? si un error page viene de location está en el mismo sitio que si viene de server
void ResponseManager::generate_status_response()
{
    Logger::getInstance() << "Generating status for client " + wss::ui_to_dec( _sys_buffer->_fd) << std::endl;

    _buffer.put_protocol("HTTP/1.1");
    _buffer.put_status(_error);
    _buffer.put_header("Server", "Webserv");
    _buffer.put_header_time("Date", time(NULL));

    if (_error.status() == METHOD_NOT_ALLOWED)
    {
        std::vector<HTTPMethod> methods = get_allowed_methods();
        std::string allowed;
        for (std::vector<HTTPMethod>::iterator it = methods.begin(); it != methods.end(); it ++)
        {
            if (it != methods.begin())
                allowed += ", ";
            allowed += method::method_to_str(*it);
        }
        _buffer.put_header("Allow", allowed);
    }

    if (_error.status() >= 400) {
        _buffer.put_header("Connection", "close");
    }

    // Intentar obtener path de custom error page
    // Lo usaremos cuando este listo el epoll con fd del error page custom, ahora lo dejo aqui y paso a custom...
    if (_server) {
        std::string error_page_path = _server->getErrorPage(_error.status(), _location);
        if (!error_page_path.empty()) {
            Logger::getInstance().info("Custom error page configured: " + error_page_path + " (using default for now)");
            // TODO: implement lectura fichero error page path y meterlo en budfer
        }
    }
    
    // fallback a default error page
    std::string error_body = generate_default_error_html();
    _buffer.put_header_number("Content-Length", error_body.size());

    _buffer.put_new_line();
    _buffer.put_body(error_body);
    
    // Intentar obtener path de custom error page

    Logger::getInstance() 
    << wss::ui_to_dec( _sys_buffer->_fd) 
    + ". Full planned response: \n" 
    + std::string(_buffer.itbegin(), _buffer.itend()) 
    << std::endl;

    _status = WRITING_RESPONSE;
}

std::string ResponseManager::generate_default_error_html()
{
    std::ostringstream html;
    int code = static_cast<int>(_error.status());
    
    html << "<!DOCTYPE html>\n"
         << "<html>\n"
         << "<head><title>Error " << code << "</title></head>\n"
         << "<body>\n"
         << "<h1>" << code << " " << status::status_to_text(_error.status()) << "</h1>\n"
         << "<p>" << _error.msg() << "</p>\n"
         << "<hr><p>webserv/1.0</p>\n"
         << "</body>\n"
         << "</html>";
    
    return html.str();
}

void ResponseManager::process()
{
    switch (_status)
    {
        case WAITING_REQUEST: generate_response(); break;
        case READING_FILE: read_file(); break; 
        case WRITING_FILE: write_file(); break ;
        case WRITING_RESPONSE: write_response(); break;
        case DONE: throw std::runtime_error("Code error: ResponseManager is DONE but tried to process");
        default: throw std::runtime_error("Code error: Unknown ResponseManager status");
    }
}

void ResponseManager::write_response()
{
    size_t max = _WRITE_BUFFER_SIZE;
    size_t write_qty = std::min<size_t>(max, _buffer.size());
    ssize_t written_bytes = _sys_buffer->write(_buffer.get_start(), write_qty);
    if (written_bytes > 0)
    {
        _buffer.consume_bytes(written_bytes);

        if (_buffer.size() == 0) {
            _file.close();
            _status = DONE;
        }
    }
    else if (written_bytes == 0)
    {
        _buffer.clear();
        _file.close();
        _status = DONE;
    }
    else
    {
        Logger & i = Logger::getInstance();
        i.error("Writing response, something went wrong with the operation. Can't reply with an status to the client. Must close: " + std::string(strerror(errno)));
        CODE_ERR("Writing response, something went wrong with the operation. Can't reply with an status to the client. Must close.");
    }
}

bool ResponseManager::response_done(){return _buffer.size() == 0;}

std::string const ResponseManager::get_host_path()
{
    // Same problem as always. Was it set? Was it empty?
    // USING LOCATION->getRoot(), then SERVER, then DEFAULT
    
    std::string root_path;
    
    if (_location && !_location->getRoot().empty()) {
        root_path = _location->getRoot();
    } else if (_server && !_server->getRoot().empty()) {
        root_path = _server->getRoot();
    } else {
        root_path = "/var/www/html";  // DEFAULT
    }
    
    // Temp (Instead of doing this many times, could be better to pre calculate it)
    return root_path + _request.uri.path;
}

std::vector<HTTPMethod> ResponseManager::get_allowed_methods()
{
    // Hard to tell because both vectors could be empty, meaning... Not allowed or not set?
    // Probably better if they parse the methods to the ENUMS.
    // CONFIGURATION HIERARCHY: LOCATION > SERVER > DEFAULT

    std::vector<std::string> method_strings;
    
    // USING LOCATION->getMethods(), then SERVER, then DEFAULT
    if (_location && !_location->getMethods().empty()) {
        method_strings = _location->getMethods();
    } else if (_server && !_server->getAllowMethods().empty()) {
        method_strings = _server->getAllowMethods();
    } else {
        // DEFAULT METHODS, MUST REMOVE SOME? ONLY GET SHOULD STAY?
        method_strings.push_back("GET");
        method_strings.push_back("POST");
        method_strings.push_back("DELETE");
    }

    std::vector<HTTPMethod> real_methods;

    // Tempx2 (Parse to enums just once)
    for (std::vector<std::string>::const_iterator it = method_strings.begin(); it != method_strings.end(); it ++)
    {
        HTTPMethod m = method::str_to_method(*it);
        if (m != NOMETHOD)
            real_methods.push_back(m);
    }

    return real_methods;
}

bool ResponseManager::allow_upload()
{
    // USING SERVER->GetAllowUpload() FOR NO LOCATION CASES, then DEFAULT
    if (_location) {
        return _location->getAllowUpload();
    }
    if (_server) {
        return _server->getAllowUpload();
    }
    return false;  // DEFAULT: FALSE
}
    
bool ResponseManager::is_autoindex()
{
    // USING getAutoindex() for LOCATION, then SERVER, then DEFAULT
    if (_location && _location->getAutoindex() != AINDX_DEF_OFF) {
        return _location->getAutoindex() == AINDX_LOC_ON;
    }
    
    if (_server) {
        AutoIndexState serv_state = _server->getAutoindex(NULL);
        if (serv_state == AINDX_SERV_ON) return true;
        if (serv_state == AINDX_SERV_OFF) return false;
    }
    
    return false;  // DEFAULT: FALSE
}
=== ./src/parse/ElementParser.cpp ===
#include "ElementParser.hpp"
#include "RequestParser.hpp"
#include "HTTPError.hpp"

ElementParser::ElementParser(HTTPError & error):_error(error){}

void ElementParser::parse_method(std::string::iterator & begin, std::string::iterator & end, HTTPMethod & method)
{
    std::string method_str(begin, end);
    wss::to_upper(method_str);
    method = method::str_to_method(method_str);

    if (method != NOMETHOD)
        return ;
    while (begin != end)
    {
        if (!parse::is_alpha(*begin))
            return _error.set("Method, unexpected character", BAD_REQUEST);
        begin ++;
    }
}

void ElementParser::parse_protocol(std::string::iterator & begin, std::string::iterator & end, std::string & protocol)
{
    protocol = std::string(begin, end);
    wss::to_upper(protocol);
    while (begin != end)
    {
        if (!parse::is_protocol_char(*begin))
            return _error.set("Protocol, unexpected character", BAD_REQUEST);
        begin ++;
    }
}

void ElementParser::parse_path(std::string::iterator & begin, std::string::iterator & end, std::string & path)
{
    path = std::string(begin, end);
    while (begin != end)
    {
        if (*begin != '/' && !parse::is_pchar(*begin))
            return _error.set("Path, unexpected character", BAD_REQUEST);
        begin ++;
    }
    normalize_path(path);
    percentage_decode(path);
}

void ElementParser::parse_query(std::string::iterator & begin, std::string::iterator & end, std::string & query)
{
    query = std::string(begin, end);
    while (begin != end)
    {
        if (!parse::is_query_char(*begin))
            return _error.set("Query, unexpected character", BAD_REQUEST);
        begin ++;
    }
    percentage_decode(query);
}

void ElementParser::parse_field_value(std::string::iterator & begin, std::string::iterator & end, std::string & value)
{
    value = std::string(begin, end);

    while (begin != end)
    {
        if (!parse::is_field_value_char(*begin))
            return _error.set("field value, unexpected character", BAD_REQUEST);
        begin ++;
    }
    parse::sanitize_header_value(value.begin(), value.end());
}

void ElementParser::parse_field_token(std::string::iterator & begin, std::string::iterator & end, std::string & name)
{
    name = std::string(begin, end);

    while (begin != end)
    {
        if (!parse::is_token_char(*begin))
            return _error.set("field token, unexpected character", BAD_REQUEST);
        begin ++;
    }
    wss::to_lower(name);
}


void ElementParser::parse_fragment(std::string::iterator & begin, std::string::iterator & end, std::string & fragment)
{
    fragment = std::string(begin, end);
    while (begin != end)
    {
        if (!parse::is_fragment_char(*begin))
            return _error.set("URL, unexpected character", BAD_REQUEST);
        begin++;
    }
}

void ElementParser::parse_host(std::string::iterator & begin, std::string::iterator & end, std::string & host)
{
    host = std::string(begin, end);
    if (*begin == '[')
    {
        return _error.set("Host, the only IP protocol supported is IPv4", BAD_REQUEST);
        begin ++;
    }
    while (begin != end)
    {
        if (!parse::is_host_char(*begin))
            return _error.set("Host, unexpected character", BAD_REQUEST);
        begin ++;
    }
    percentage_decode(host);
    wss::to_lower(host);
}

void ElementParser::parse_port(std::string::iterator & begin, std::string::iterator & end, int & port)
{
    port = 0;

    while (begin != end)
    {
        if (!parse::is_digit(*begin))
            return _error.set("Port, unexpected character", BAD_REQUEST);
        port = port * 10 + *begin - '0';
        if (port > 65535)
            return _error.set("Port, too big (max: 65535 for TCP)", BAD_REQUEST);
        begin ++;
    }
}

void ElementParser::parse_content_length_field(std::string::iterator & begin, std::string::iterator & end, int & length)
{
    length = 0;
    while (begin != end)
    {
        if (!parse::is_digit(*begin))
            return _error.set("Header Content-Length, unexpected character", BAD_REQUEST);
        length = length * 10 + *begin - '0';
        if (static_cast<size_t>(length) >= RequestParser::MAX_CONTENT_LENGTH)
            return _error.set("Header Content-Length, too large", CONTENT_TOO_LARGE);
        begin ++;
    }
}

// End and begin point to  '"'
void ElementParser::parse_dquote_string(std::string::iterator & begin, std::string::iterator & end, std::string & str)
{
    begin ++;
    str.reserve(std::distance(begin, end));

    while (begin != end)
    {
        if (*begin == '\\')
        {
            if (begin + 1 == end || !parse::is_quoted_pair_char(*(begin + 1)))
                return _error.set("quoted string, unexpected character", BAD_REQUEST);
            str.push_back(*(begin + 1));
            begin += 2;
        }
        else 
        {
            if (!parse::is_qdtext_char(*begin))
                return _error.set("quoted string, unexpected character", BAD_REQUEST);
            str.push_back(*begin);
            begin ++;
        }
    }
}

void ElementParser::parse_comma_separated_values(std::string::iterator & begin, std::string::iterator & end, std::vector<Coding> & values)
{
    while (1)
    {
        Coding csf;
        std::string::iterator head;

        // Get name
        head = wss::skip_until(begin, end, ",; ");
        parse_field_token(begin, head, csf.name);
        if (csf.name.empty())
            return _error.set("Comma separated field, empty field name", BAD_REQUEST);
        
        // Parse params
        begin = wss::skip_ascii_whitespace(head, end);
        while (begin != end && *begin == ';')
        {
            std::string param_name, param_value;
        
            // Param name
            begin = wss::skip_ascii_whitespace(begin + 1, end);
            head = wss::skip_until(begin, end, "= \t");
            parse_field_token(begin, head, param_name);
            if (param_name.empty())
                return _error.set("comma separated field, empty parameter name", BAD_REQUEST);
     
            // Parse value (Skip to value)
            begin = wss::skip_ascii_whitespace(head, end);
            if (begin != end && *begin != '=')
                return _error.set("Comma separated parameter, unexpected character", BAD_REQUEST);
            if (begin == end || begin + 1 == end)
                return _error.set("Comma separated parameter, empty parameter value", BAD_REQUEST);
            begin = wss::skip_ascii_whitespace(begin + 1, end);

            // Parse value
            if (*begin == '"')
            {
                head = wss::skip_until_dquoted_string_end(begin + 1, end);
                if (head == end)
                    return _error.set("Comma separated parameter, closing dquote missing", BAD_REQUEST);
                parse_dquote_string(begin, head, param_value);

                head ++; // Skip the last '"'
            }
            else 
            {
                head = wss::skip_until(begin, end, ", \t");
                parse_field_token(begin, head, param_value);
            }
            if (param_value.empty())
                return _error.set("Comma separated parameter, empty parameter value", BAD_REQUEST);

            // Put value and push begin iterator
            csf.parameters.push_back(std::pair<std::string, std::string>(param_name, param_value));
            begin = wss::skip_ascii_whitespace(head, end);
        }

        values.push_back(csf);
    
        // End of current field
        if (begin != end && *begin == ',')
        {
            begin = wss::skip_ascii_whitespace(begin + 1, end);
            continue ;
        }
        else if (begin != end)
            return _error.set("Comma separated field, unexpected character", BAD_REQUEST);
        break ;
    } 
}


void ElementParser::parse_schema(std::string::iterator & begin, std::string::iterator & end, std::string & schema)
{
    schema = std::string(begin, end);
    while (begin != end)
    {
        if (!parse::is_alpha(*begin))
            return _error.set("Schema, unexpected character", BAD_REQUEST);
        begin ++;
    }
    wss::to_lower(schema);
}

void ElementParser::replace_percentage(std::string::iterator & it, std::string & str)
{
    if (it + 2 >= str.end() || !parse::is_hexa_char(*(it + 1)) || !parse::is_hexa_char(*(it + 2)))
        return _error.set("Percentage encoding, unexpected character", BAD_REQUEST);
    *it = parse::hex_to_byte(*(it + 1)) * 16 + parse::hex_to_byte(*(it + 2));
    it = str.erase(it + 1, it + 3);
}

void ElementParser::percentage_decode(std::string & str)
{
    for (std::string::iterator it = str.begin(); it != str.end();)
        if (_error.status() != OK)
            return;
        else if (*it == '%')
            replace_percentage(it, str);
        else
            it ++;
}

void ElementParser::normalize_path(std::string & str)
{
    std::string::iterator it = str.begin();
    std::string out = "";

    while (it != str.end())
    {  
        while (std::distance(it, str.end()) >= 2 && wss::str_equal(it, 2, "//"))
            it ++;
        if (std::distance(it, str.end()) >= 3 && wss::str_equal(it, 3, "../"))
            it += 3;
        else if (std::distance(it, str.end()) >= 2 && wss::str_equal(it, 2, "./"))
            it += 2;

        else if (std::distance(it, str.end()) >= 3 && wss::str_equal(it, 3, "/./"))
            it += 2;
        else if (std::distance(it, str.end()) == 2 && wss::str_equal(it, "/."))
        {
            it ++;
            *it = '/';
        }

        else if (std::distance(it, str.end()) >= 4 && wss::str_equal(it, 4, "/../"))
        {
            it += 3;
            wss::remove_uri_segment(out);
        }
        else if (std::distance(it, str.end()) == 3 && wss::str_equal(it, "/.."))
        {
            it += 2;
            *it = '/';
            wss::remove_uri_segment(out);
        }

        else if (wss::str_equal(it, ".."))
            it +=2;
        else if (wss::str_equal(it, "."))
            it ++;

        else
            it = wss::move_uri_segment(out, str, it);
    }
    if (out.empty())
        out = "/";
    str = out;
}

=== ./src/parse/RequestManager.cpp ===
#include "RequestManager.hpp"

RequestManager::RequestManager(HTTPRequest & request, HTTPError & error, SysBufferFactory::sys_buffer_type type, int fd)
:_request(request), _error(error),
_validator(_request, _error),
_element_parser(_error),
_request_parser(_request, _error, _element_parser),
_sys_buffer(SysBufferFactory::get_buffer(type, fd))
{}

RequestManager::~RequestManager(){delete _sys_buffer;};

void RequestManager::process()
{
    bool parse = true;
    bool has_read = false;

    while (_error.status() == OK && !request_done())
    {
        switch (_request_parser.get_status())
        {
            case RequestParser::PRS_FIRST_LINE:
                parse = _request_parser.test_first_line();
                if (parse)
                {
                    _request_parser.parse_first_line();
                    if (_error.status() == OK) _validator.validate_first_line(_request);
                }
                break;
            case RequestParser::PRS_HEADER_LINE:
                parse = _request_parser.test_header_line();
                if (parse)
                    _request_parser.parse_header_line();
                if (_error.status() == OK && _request_parser.get_status() != RequestParser::PRS_HEADER_LINE)
                    _validator.validate_headers(_request, _request.headers);
                break ;
            case RequestParser::PRS_BODY:
                parse = _request_parser.test_body();
                if (parse)
                {
                    _request_parser.parse_body();
                    if (_error.status() == OK) _validator.validate_body(_request.body);
                }
                break ;
            case RequestParser::PRS_CHUNKED_SIZE:
                parse = _request_parser.test_chunk_size();
                if (parse)
                    _request_parser.parse_chunked_size();
                break ;
            case RequestParser::PRS_CHUNKED_BODY: // TODO: Validate body?
                parse = _request_parser.test_chunk_body();
                if (parse)
                    _request_parser.parse_chunked_body();
                break ;            
            case RequestParser::PRS_TRAILER_LINE: parse = _request_parser.test_trailer_line(); break ;
            case RequestParser::PRS_DONE: parse = false; break ;  
            default: throw new std::runtime_error("Code error reading Request Parser status");
        }
        if (!parse && _error.status() == OK && !request_done())
        {
            if (has_read)
                break ;
            has_read = true;
            ssize_t read_size = _sys_buffer->read(_read_buffer, _READ_BUFFER_SIZE);
            if (read_size <= 0)
                break ;
            _request_parser.append(_read_buffer, read_size);
        }
    }
}

bool RequestManager::request_done() const
{
    return _request_parser.get_status() == RequestParser::PRS_DONE;
}

void RequestManager::new_request()
{
    _error.set("", OK); _request.reset(); _request_parser.new_request();
}

HTTPError & RequestManager::gerError(){return _error;}
=== ./src/parse/RequestParser.cpp ===
#include "RequestParser.hpp"

const RequestParser::wsHeaders RequestParser::headers[] = {
    {"host", &RequestParser::parse_host_field},
    {"content-length", &RequestParser::parse_content_length_field},
    {"transfer-encoding", &RequestParser::parse_transfer_encoding_field},
    {"connection", &RequestParser::parse_connection_field},
    {"expect", &RequestParser::parse_expect_field},
    {"cookie", &RequestParser::parse_cookie_field},
    {"content-type", &RequestParser::parse_content_type_field},
    {"", NULL}
};

const size_t RequestParser::URI_MAX_LENGTH = 2000;
const size_t RequestParser::FIRST_LINE_MAX_LENGTH = 8000;
const size_t RequestParser::HEADER_LINE_MAX_LENGTH = 8000;
const size_t RequestParser::MAX_HEADER_FIELDS = 100;
const size_t RequestParser::MAX_TRAILER_FIELDS = 20;
const size_t RequestParser::MAX_CONTENT_LENGTH = 1*512*1024;
const size_t RequestParser::MAX_CHUNK_SIZE = 1*512 *1024;;
const size_t RequestParser::CHUNKED_SIZE_LINE_MAX_LENGTH = 200;

RequestParser::RequestParser(HTTPRequest & request, HTTPError & error, ElementParser & element_parser)
:_request(request), 
_error(error),
_element_parser(element_parser),
_status(PRS_FIRST_LINE),
_empty_skip_count(0),
_header_field_count(0),
_trailer_field_count(0),
_chunk_length(0)
{}

// Request parse managment
void RequestParser::new_request()
{
    _empty_skip_count = 0;
    _status = PRS_FIRST_LINE;
    _buffer.new_request();
    _header_field_count = 0;
    _trailer_field_count = 0;
    _chunk_length = 0;
}

RequestParser::parsing_status RequestParser::get_status() const {return _status;}

void RequestParser::append(uint8_t const * str, ssize_t size) {_buffer.append(str, size);}


// Parsing - Testers
bool RequestParser::test_first_line()
{
    _processing = _buffer.get_crlf_line(_begin, _end);
    if (static_cast<size_t>(_buffer.previous_read_size()) >= RequestParser::FIRST_LINE_MAX_LENGTH)
    {
        _error.set("Request first line length is too long", BAD_REQUEST);
        return false;
    }
    if (!_processing)
        return false;
    if (_begin == _end)
    {
        _empty_skip_count ++;
        if (_empty_skip_count > 1)
            _error.set("Only one empty line is allowed before request", BAD_REQUEST);
        return false;
     }
    return true;
}

bool RequestParser::test_chunk_size()
{
    _processing = _buffer.get_crlf_line(_begin, _end);
    if (static_cast<size_t>(_buffer.previous_read_size()) >= RequestParser::CHUNKED_SIZE_LINE_MAX_LENGTH)
    {
        _error.set("Chunk size line too long", BAD_REQUEST);
        return false;
    }
    return _processing;
}

bool RequestParser::test_chunk_body()
{
    return _buffer.get_chunk(_chunk_length, _begin, _end);
}

bool RequestParser::test_body()
{
    if (_request.headers.content_length <= 0)
    {
        _status = PRS_DONE;
        return false;
    }
    return _buffer.get_chunk(_request.headers.content_length, _begin, _end);
}

bool RequestParser::test_trailer_line()
{
    _processing = _buffer.get_crlf_line(_begin, _end);
    if (static_cast<size_t>(_buffer.previous_read_size()) >= RequestParser::HEADER_LINE_MAX_LENGTH || _trailer_field_count >= RequestParser::MAX_TRAILER_FIELDS)
    {
        _error.set("Request trailer field", REQUEST_HEADER_FIELDS_TOO_LARGE);
        return false;
    }
    if (!_processing)
        return _processing ;
    _trailer_field_count ++;
    if (_begin == _end)
    {
        _status = PRS_DONE;
        return false;
    }
    return _processing;
}

bool RequestParser::test_header_line()
{
    _processing = _buffer.get_crlf_line(_begin, _end);
    if (static_cast<size_t>(_buffer.previous_read_size()) >= RequestParser::HEADER_LINE_MAX_LENGTH || _header_field_count >= RequestParser::MAX_HEADER_FIELDS)
    {
        _error.set("Request headers", REQUEST_HEADER_FIELDS_TOO_LARGE);
        return false;
    }
    if (!_processing)
        return _processing;
    _header_field_count ++;
    if (_begin == _end)
    {
        if (!_request.headers.transfer_encodings.empty() && _request.headers.transfer_encodings.back().name == "chunked")
            _status = PRS_CHUNKED_SIZE;
        else
            _status = PRS_BODY;
        return true;
    }
    return _processing;
}

void RequestParser::parse_first_line()
{
    parse::first_line_sanitize(_begin, _end);
    parse_method();
    parse_uri();
    parse_protocol();
    _status = PRS_HEADER_LINE;
}

void RequestParser::parse_method()
{
    if (*_begin == ' ')
    {
        Logger::getInstance().warning("First line, space before method");
        _begin = wss::skip_whitespace(_begin, _end);
    }

    std::string::iterator token_end = wss::skip_until(_begin, _end, " ");
    _element_parser.parse_method(_begin, token_end, _request.method);
    _begin = token_end;
}

void RequestParser::parse_protocol()
{
    // Skip to start of Protocol and checks
    if (_begin != _end && _begin + 1 != _end && *_begin == ' ' && *(_begin + 1) == ' ')
        Logger::getInstance().warning("protocol, extra whitespace after uri");
    _begin = wss::skip_whitespace(_begin, _end);
    if (_begin == _end)
        return _error.set("protocol not found", BAD_REQUEST);
    _end = wss::skip_until(_begin, _end, " ");

    // Parse
    _element_parser.parse_protocol(_begin, _end, _request.protocol);

    // Final checks
    if (_end != _end && *_end == ' ')
        Logger::getInstance().warning("request line, extra whitespace after protocol");

    if (wss::skip_whitespace(_end, _end) != _end)
        _error.set("Extra content after protocol", BAD_REQUEST);
} 

void RequestParser::parse_header_line()
{

    if (_begin == _end)
        return ;
    
    std::string name, value;
    std::string::iterator token_end, token_start = _begin;
    
    // Parse name
    token_end = wss::skip_until(token_start, _end, ":");
    if (token_end == _end)
        return _error.set("Token ':' not found on field", BAD_REQUEST);
    if (token_end == token_start)
        return _error.set("Field name is empty", BAD_REQUEST);
    _element_parser.parse_field_token(_begin, token_end, name);
    
    if (name == "*" || name == "close")
        return _error.set("Header field name " + name + " is reserved", BAD_REQUEST);
    // Parse value
    token_start = wss::skip_ascii_whitespace(token_end + 1, _end);
    if (token_start != _end)
        token_end = wss::skip_ascii_whitespace_r(_end, token_start);
    else
        token_end = _end;
    _element_parser.parse_field_value(token_start, token_end, value);

    _request.headers.put(name, value);

    process_headers();
}

void RequestParser::parse_body()
{
    _request.body.content = std::string(_begin, _end);
    _status = PRS_DONE;
}

void RequestParser::parse_chunked_size()
{
    std::string::iterator token_end, token_start = _begin;

    // Delimit hex token
    token_end = wss::skip_hexa_token(token_start, _end);
    if (token_start == token_end)
        return _error.set("The chunk size line must have at least one hex digit", BAD_REQUEST);

    // Get hexa value
    _chunk_length = parse::s_to_hex(token_start, token_end, RequestParser::MAX_CHUNK_SIZE);
    if (_chunk_length == 0)
        _status = PRS_TRAILER_LINE;
    else
        _status = PRS_CHUNKED_BODY;
    if (_chunk_length  >= RequestParser::MAX_CHUNK_SIZE)
        return _error.set("Chunk size too big", BAD_REQUEST);
    if (_request.body.content.size() + _chunk_length >= RequestParser::MAX_CONTENT_LENGTH)
        return _error.set("Chunked body too big", BAD_REQUEST);
}

void RequestParser::parse_chunked_body()
{
    _request.body.content += std::string(_begin, _end);
    _status = PRS_CHUNKED_SIZE;
}

void RequestParser::parse_uri()
{
    std::string::iterator token_end, token_start = _begin;

    // Skip to start of URI
    if (token_start != _end && token_start + 1 != _end && *token_start == ' ' && *(token_start + 1) == ' ')
        Logger::getInstance().warning("Extra white space after request URI (Client #)");
    token_start = wss::skip_whitespace(token_start, _end);
    if (token_start == _end)
        return _error.set("URI not found", BAD_REQUEST);

    // Check URI length
    std::string::iterator uri_limit = wss::skip_until(token_start, token_end, " ");
    if (static_cast<size_t>(std::distance(token_start, uri_limit)) >= RequestParser::URI_MAX_LENGTH)
        return _error.set("Request uri", URI_TOO_LONG);

    // Parse
    if (token_start != _end && *token_start == '/')
        get_path(token_start, token_end);
    else if (token_start != _end)
    {
        get_schema(token_start, token_end);
        if (has_authority(token_start, token_end))
            get_hier_part(token_start, token_end);
        else
            get_path(token_start, token_end);
    }
    if (token_start != _end && *token_start == '?')
        get_query(token_start, token_end);
    if (token_start != _end && *token_start == '#')
        get_fragment(token_start, token_end);

    // Set default port if not found
    if (_request.uri.port == -1)
        _request.uri.port = 80;

    _begin = token_start;
}

// Secondary parsing functions
void RequestParser::get_hier_part(std::string::iterator & token_start, std::string::iterator & token_end)
{ 
    token_start += 2; // Skip '//'

    // Find and skip userinfo if present
    token_end = wss::skip_until(token_start, _end, "@");
    if (token_end != _end && *token_end == '@')
        return _error.set("authority, userinfo '@' is deprecated", BAD_REQUEST);
    if (token_start == _end)
        return _error.set("Host not found on URI", BAD_REQUEST);

    // Find host (Until path or end)
    token_end = wss::skip_until(token_start, _end, " :?#/");
    if (token_end == token_start)
        return _error.set("Host not found on URI", BAD_REQUEST);
    else
        _element_parser.parse_host(token_start, token_end, _request.uri.host);
    token_start = token_end;

    // Find port
    if (token_end != _end && *token_end == ':')
    {
        token_start ++;
        token_end = wss::skip_until(token_start, _end, " ?#/");
        _element_parser.parse_port(token_start, token_end, _request.uri.port);
        token_start = token_end;
    }

    if (token_end != _end && *token_end == '/')
        get_path(token_start, token_end);
}

// Header field parsing

void RequestParser::parse_host_field(std::string & value)
{
    std::string::iterator token_start = value.begin();
    std::string::iterator token_end = wss::skip_until(value.begin(), value.end(), ":");
    _element_parser.parse_host(token_start, token_end, _request.headers.host);
    if (token_end != value.end() && *token_end == ':')
    {
        token_start = token_end + 1;
        token_end = value.end();
        _element_parser.parse_port(token_start, token_end, _request.headers.port);
    }
    else
        _request.headers.port = 80;
}

void RequestParser::parse_content_length_field(std::string & value)
{
    std::string::iterator token_start = value.begin();
    std::string::iterator token_end = value.end();

    if (value.find(",") == std::string::npos)
        _element_parser.parse_content_length_field(token_start, token_end, _request.headers.content_length);
    else 
    {
        std::vector<Coding> csfs;
        _element_parser.parse_comma_separated_values(token_start, token_end, csfs);
        for (std::vector<Coding>::iterator it = csfs.begin(); it != csfs.end(); it ++)
        {
            ssize_t prev_value = _request.headers.content_length;
            token_start = it->name.begin();
            token_end = it->name.end();

            if (!it->parameters.empty())
                return _error.set("Content-Length values can't have parameters", BAD_REQUEST);
            _element_parser.parse_content_length_field(token_start, token_end, _request.headers.content_length);
            if (prev_value != -1 && prev_value != _request.headers.content_length)
                return _error.set("Content-Length has incoherent, different values: " + value, BAD_REQUEST);
        }
    }
}

void RequestParser::parse_transfer_encoding_field(std::string & value)
{
    parse_list(value.begin(), value.end(), &RequestParser::parse_transfer_encoding_element);
}

void RequestParser::parse_connection_field(std::string & value)
{
    parse_list(value.begin(), value.end(), &RequestParser::parse_connection_element);
}

void RequestParser::parse_expect_field(std::string & value)
{
    parse_list(value.begin(), value.end(), &RequestParser::parse_expect_element);
}

/*
    parameters      = *( OWS ";" OWS [ parameter ] )
    parameter       = parameter-name "=" parameter-value
    parameter-name  = token
    parameter-value = ( token / quoted-string )

    1. See if parameter exists
    2. Skip OWS;OWS - If not error
    3. Parse token=
    4. Parse token/quotedstring
*/
void RequestParser::parse_parameters(std::string::iterator begin, std::string::iterator end, std::vector<std::pair<std::string, std::string> > & parameters)
{
    std::string::iterator value_end, value_start, name_end, name_start, head;

    while (begin != end && _error.status() == OK) // 1
    {
        // 2
        head = wss::skip_ascii_whitespace(begin, end);
        if (head == end || *head != ';')
            return _error.set("Parameters, expected ; separator", BAD_REQUEST);
        head = wss::skip_ascii_whitespace(head + 1, end);

        // 3
        name_start = head;
        name_end = wss::skip_http_token(name_start, end);
        if (name_end == name_start || name_end == end || *name_end != '=')
            return _error.set("Parameters, name must be non empty and precede a '='", BAD_REQUEST);
        
        // 4
        head = name_end + 1;
        if (head == end)
            return _error.set("Parameters, value not found", BAD_REQUEST);
        if (head != end && *head == '"')
        {
            std::string val;
            std::string::iterator dquote_end = wss::skip_until_dquoted_string_end(head + 1, end);
            if (dquote_end == end || *dquote_end != '"')
                return _error.set("Parameters, closing dquote missing", BAD_REQUEST);
            _element_parser.parse_dquote_string(head, dquote_end, val); // Head and end points to ", updates head to last " 
            parameters.push_back(std::make_pair(std::string(name_start, name_end), val));
            head = dquote_end + 1;
        }
        else 
        {
            value_start = head;
            value_end = wss::skip_http_token(value_start, end);
            parameters.push_back(std::make_pair(std::string(name_start, name_end), std::string(value_start, value_end)));
            head = value_end;
        }
        begin = head;
    }
}

void RequestParser::parse_content_type_field(std::string & value)
{
    std::string::iterator head = value.begin();

    while (head != value.end() && parse::is_token_char(*head))
        head ++;
    _request.headers.content_type.type = std::string(value.begin(), head);

    if (head == value.end() || *head != '/')
        return _error.set("Media-type, expected subtype separator '/'", BAD_REQUEST);
    head ++;

    std::string::iterator begin = head;
    while (head != value.end() && parse::is_token_char(*head))
        head ++;
    _request.headers.content_type.subtype = std::string(begin, head);
    
    wss::to_lower(_request.headers.content_type.type);
    wss::to_lower(_request.headers.content_type.subtype);

    if (_request.headers.content_type.type == "" || _request.headers.content_type.subtype == "")
        return _error.set("Media-Type, empty type or subtype", BAD_REQUEST);
    
    parse_parameters(head, value.end(), _request.headers.content_type.parameters);
}

void RequestParser::parse_cookie_field(std::string & value)
{
    std::string::iterator head = value.begin();
    std::string::iterator name_start, name_end, value_start, value_end;
    bool dquote;

    while (head != value.end())
    {
        // Reset tokens
        name_start = head;
        name_end = head;

        // Parse name
        while (name_end != value.end() && parse::is_token_char(*name_end))
            name_end ++;
        if (name_start == name_end)
            return _error.set("Cookie name, empty", BAD_REQUEST);
        if (name_end == value.end() || *name_end != '=')
            return _error.set("Cookie name, '=' not found/unexpected character", BAD_REQUEST);
       
        // Parse value
        value_start = name_end + 1;
        if (value_start != value.end() && *value_start == '"')
        {
            value_start ++;
            dquote = true;
        }
        else
            dquote = false;

        head = value_start;
        while (head != value.end() && parse::is_cookie_char(*head))
            head ++;
        if (dquote && (head == value.end() || *head != '"'))
            return _error.set("Cookie value, unclosed quote/unexpected character", BAD_REQUEST);
        value_end = head;
        _request.headers.put_cookie(name_start, name_end, value_start, value_end);
        if (dquote)
            head ++;
    
        // Skip (";" SP). If any found, it's a different cookie. Else, last.
        if (head == value.end())
            return ;
        if (*head != ';')
            return _error.set("Cookie, unexpected character", BAD_REQUEST);
        head ++;
        if (head == value.end() || *head != ' ')
            return _error.set("Cookie, unexpected character", BAD_REQUEST);
        head ++;
    }
}

// Auxiliary

void RequestParser::process_headers()
{
    for (std::map<std::string, std::string>::iterator it = _request.headers.fields.begin(); it != _request.headers.fields.end(); it ++)
        for (wsHeaders const * hdr = headers; hdr->parser_f != NULL; hdr ++)
            if (it->first == hdr->name)
                (this->*hdr->parser_f)(it->second);
}

bool RequestParser::has_authority(std::string::iterator & token_start, std::string::iterator & token_end) const
{
    (void)token_end; // Suppress unused parameter warning
    return token_start + 1 < _end && *token_start == '/' && *(token_start + 1) == '/';
}

void RequestParser::get_path(std::string::iterator & token_start, std::string::iterator & token_end)
{
    token_end = wss::skip_until(token_start, _end, " ?#");
    _element_parser.parse_path(token_start, token_end, _request.uri.path);
    token_start = token_end;
}


void RequestParser::get_schema(std::string::iterator & token_start, std::string::iterator & token_end)
{
    token_end = wss::skip_until(token_start, _end, ":");
    if (token_end == _end)
        return _error.set("URI schema, separator ':' not found", BAD_REQUEST);
    _element_parser.parse_schema(token_start, token_end, _request.uri.schema);
    token_start = token_end + 1;
}

void RequestParser::get_query(std::string::iterator & token_start, std::string::iterator & token_end)
{
    token_start ++;
    token_end = wss::skip_until(token_start, _end, " #");
    _element_parser.parse_query(token_start, token_end, _request.uri.query);
    token_start = token_end;
}

void RequestParser::get_fragment(std::string::iterator & token_start, std::string::iterator & token_end)
{
    token_start ++;
    token_end = wss::skip_until(token_start, _end, " ");
    _element_parser.parse_fragment(token_start, token_end, _request.uri.fragment);
    token_start = token_end;
}

// Debug
void RequestParser::dump_remainder() const
{
    Logger::getInstance() << "Buffer remainder:\n" << std::string(_buffer.cbegin(), _buffer.cend()) << "$\n";
    if (_status != PRS_DONE)
    {
        Logger::getInstance() << "Body not fully read (Chunks are always read on one operation)\n"
        << "Read body size: " << _request.body.content.size() << ", "
        << "Content-Length: " << _request.headers.content_length << ", "
        << "Last Chunk size: " << _chunk_length << std::endl;
    }
}


void parse_dquote_string()
{

}

/*
    #element => [ element ] *( OWS "," OWS [ element ] )

    LOOP:
    1. Check if element - If, parse.
    2. If end, return
    2. Skip WS
    3. "," or error
    4. Skip WS

    element_parser should return an iterator after it last element or put an error.
*/
void RequestParser::parse_list (
    std::string::iterator token_start,    
    std::string::iterator token_end, 
    std::string::iterator (RequestParser::*element_parser)(std::string::iterator token_start, std::string::iterator token_end))
{
    std::string::iterator head = token_start;
    while (head != token_end)
    {
        if (*head != ' ' && *head != ',' && *head != '\t')
            head = (this->*element_parser)(token_start, token_end);
        if (head == token_end || _error.status() != OK)
            return ;
        
        head = wss::skip_whitespace(head, token_end);
        if (head == token_end || *head != ',')
            return _error.set("Parsing list, unexpected character", BAD_REQUEST);
        head ++;
        head = wss::skip_whitespace(head, token_end);
        token_start = head;
    }
}

std::string::iterator RequestParser::parse_transfer_encoding_element(std::string::iterator begin, std::string::iterator end)
{
    Coding csf;
    std::string::iterator head;

    // Get name
    head = wss::skip_until(begin, end, "; ");
    _element_parser.parse_field_token(begin, head, csf.name);
    if (csf.name.empty())
    {
        _error.set("Transfer encoding field, empty field name", BAD_REQUEST);
        return end;
    }
    
    // Parse params
    begin = wss::skip_ascii_whitespace(head, end);
    while (begin != end && *begin == ';')
    {
        std::string param_name, param_value;
    
        // Param name
        begin = wss::skip_ascii_whitespace(begin + 1, end);
        head = wss::skip_until(begin, end, "= \t");
        _element_parser.parse_field_token(begin, head, param_name);
        if (param_name.empty())
        {
            _error.set("comma separated field, empty parameter name", BAD_REQUEST);
            return end;
        }
    
        // Parse value (Skip to value)
        begin = wss::skip_ascii_whitespace(head, end);
        if (begin != end && *begin != '=')
        {
            _error.set("Comma separated parameter, unexpected character", BAD_REQUEST);
            return end;
        }
        if (begin == end || begin + 1 == end)
        {
            _error.set("Comma separated parameter, empty parameter value", BAD_REQUEST);
            return end;
        }
        begin = wss::skip_ascii_whitespace(begin + 1, end);

        // Parse value
        if (*begin == '"')
        {
            head = wss::skip_until_dquoted_string_end(begin + 1, end);
            if (head == end)
            {
                _error.set("Comma separated parameter, closing dquote missing", BAD_REQUEST);
                return end;
            }
            _element_parser.parse_dquote_string(begin, head, param_value);

            head ++; // Skip the last '"'
        }
        else 
        {
            head = wss::skip_until(begin, end, ", \t");
            _element_parser.parse_dquote_string(begin, head, param_value);
        }
        if (param_value.empty())
        {
            _error.set("Comma separated parameter, empty parameter value", BAD_REQUEST);
            return end;
        }

        // Put value and push begin iterator
        csf.parameters.push_back(std::pair<std::string, std::string>(param_name, param_value));
        begin = wss::skip_ascii_whitespace(head, end);
    }
    _request.headers.transfer_encodings.push_back(csf);

    return head;
}

std::string::iterator RequestParser::parse_connection_element(std::string::iterator begin, std::string::iterator end)
{
    std::string::iterator head = begin;
    while (head != end && parse::is_token_char(*head))
        head ++;
    _request.headers.connections.push_back(std::string(begin, head));
    wss::to_lower(_request.headers.connections.back());
    return head;
}

std::string::iterator RequestParser::parse_expect_element(std::string::iterator begin, std::string::iterator end)
{
    std::string::iterator head = begin;
    while (head != end && parse::is_token_char(*head))
        head ++;
    _request.headers.expectations.push_back(std::string(begin, head));
    wss::to_lower(_request.headers.expectations.back());
    return head;
}


std::string const  RequestParser::get_remainder() const
{
    return std::string(_buffer.cbegin(), _buffer.cend());
}
=== ./src/Utils.cpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Utils.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mvisca-g <mvisca-g@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/30 13:58:20 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 19:07:50 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Utils.hpp"
#include "Location.hpp"
#include "Parsed.hpp"

// Temporary color macros to fix compilation
#define RED        "\033[1;91m"
#define GREEN      "\033[1;92m"
#define YELLOW     "\033[1;93m"
#define BLUE       "\033[1;94m"
#define RESET      "\033[0m"

int checkFile(const char* argv)
{
    std::ifstream infile(argv);

    if (!infile.is_open())
    {
        std::cerr << std::endl << RED <<
        "ERROR: file does not exist or can not be opened." <<
        RESET << std::endl << std::endl;
        return (-1);
    }

    infile.seekg(0, std::ios_base::end);
    if (infile.tellg() == 0)
    {
        std::cerr << std::endl << RED <<
        "ERROR: file is empty." <<
        RESET << std::endl << std::endl;
        return (-1);
    }
    infile.seekg(0, std::ios_base::beg);

    if (infile.fail())
    {
        std::cerr << std::endl << RED <<
        "ERROR: file stream error detected." <<
        RESET << std::endl << std::endl;
        return (-1);
    }

    if (infile.is_open()) { infile.close(); }

    return (0);
}

std::string autoindexToString(AutoIndexState state)
{
    switch (state)
    {
        case AINDX_DEF_OFF:  return "DEFAULT_OFF";
        case AINDX_DEF_ON:   return "DEFAULT_ON";
        case AINDX_SERV_OFF: return "SERVER_OFF";
        case AINDX_SERV_ON:  return "SERVER_ON";
        case AINDX_LOC_OFF:  return "LOCATION_OFF";
        case AINDX_LOC_ON:   return "LOCATION_ON";
        default:             return "UNKNOWN";
    }
}

void printLocationConfig(const Location& loc)
{
	std::cout << YELLOW << "    Autoindex: " << RESET << autoindexToString(loc.getAutoindex()) << std::endl;

	std::cout << YELLOW << "    Root: " << RESET << loc.getRoot() << std::endl;
	std::vector<std::string> methods = loc.getMethods();
	std::cout << YELLOW << "    Allowed Methods:" << RESET << std::endl;
    for (size_t i = 0; i < methods.size(); ++i)
        std::cout << "      - " << methods[i] << std::endl;


	// TODO: Implement when Location class has proper getters
//	(void)loc; // Suppress unused parameter warning
//	std::cout << "    Location configuration (not implemented yet)" << std::endl;
}

void printServerConfig(const ParsedServer& config)
{

	std::cout << GREEN << "\n=== ServerConfig ===" << RESET << std::endl;

	std::cout << YELLOW << "Listen Directives:" << RESET << std::endl;
	for (size_t i = 0; i < config.listens.size(); ++i)
		std::cout << "  - " << config.listens[i].to_string() << std::endl;

	std::cout << YELLOW << "Server Names:" << RESET << std::endl;
	for (size_t i = 0; i < config.server_names.size(); ++i)
		std::cout << "  - " << config.server_names[i] << std::endl;

	std::cout << YELLOW << "Root: " << RESET << config.root << std::endl;
	
	std::cout << YELLOW << "Error Pages:" << RESET << std::endl;
	for (std::map<int, std::string>::const_iterator it = config.error_pages.begin();
		 it != config.error_pages.end(); ++it)
		std::cout << "  " << it->first << " => " << it->second << std::endl;

	std::cout << YELLOW << "Allowed Methods:" << RESET << std::endl;
	for (size_t i = 0; i < config.allow_methods.size(); ++i)
		std::cout << "  - " << config.allow_methods[i] << std::endl;

//	std::cout << YELLOW << "Autoindex: " << RESET << (config.autoindex ? "true" : "false") << std::endl;

	std::cout << YELLOW << "Autoindex: " << RESET << autoindexToString(config.autoindex) << std::endl;


	std::cout << YELLOW << "Client Max Body Size: " << RESET << config.client_max_body_size << std::endl;

	std::cout << YELLOW << "Locations:" << RESET << std::endl;
	for (std::map<std::string, Location>::const_iterator it = config.locations.begin();
		 it != config.locations.end(); ++it)
	{
		std::cout << BLUE <<"  Location block for: " << it->first << RESET << std::endl;
		printLocationConfig(it->second);
	}

	std::cout << std::endl;
}

void printParsingMessage(ParsingMessageType type)
{
	switch (type)
	{
		case DEFAULT_SERVER:
			std::cout << YELLOW << "INFO: " << RESET <<
			"According to the subject requirements, if two or more servers are configured " <<
			"with the same host:port, the first one in order is considered the primary. The " <<
			YELLOW << "[default_server]" << RESET << " directive is " << YELLOW <<
			"ignored" << RESET << "." << std::endl;
			break;
		case LOCAL_HOST:
			std::cout << YELLOW << "INFO: " << RESET <<
			"Hosts like " << YELLOW << "localhost" << RESET << " will be " << YELLOW <<
			"replaced with the real localhost. " << RESET <<
			"According to subject, if this replace will affect same host:port of other server, " <<
			YELLOW << "the first one in order is considered the primary" << RESET << "." << std::endl;
			break;
		case ASTERIKS_HOST:
			std::cout << YELLOW << "INFO: " << RESET <<
			"Hosts like " << YELLOW << "*" << RESET << " will be " << YELLOW <<
			"replaced with default host. " << RESET <<
			"According to subject, if this replace will affect same host:port of other server, " <<
			YELLOW << "the first one in order is considered the primary" << RESET << "." << std::endl;
			break;
		default:
			std::cout << YELLOW << "INFO: " << RESET << "Unknown parsing state." << std::endl;
			break;
	}
}

std::string getLoopbackAddress()
{
	struct ifaddrs* ifaddr;
	if (getifaddrs(&ifaddr) == -1)
		return ("0.0.0.0");

	std::string loopbackIP = "127.0.0.1";
	for (struct ifaddrs* ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) 
	{
		if (!ifa->ifa_addr)
			continue;

		if (ifa->ifa_addr->sa_family == AF_INET && std::string(ifa->ifa_name) == "lo")
		{
			char addrBuf[INET_ADDRSTRLEN];
			void* addrPtr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
			inet_ntop(AF_INET, addrPtr, addrBuf, INET_ADDRSTRLEN);
			loopbackIP = std::string(addrBuf);
			break;
		}
	}

	freeifaddrs(ifaddr);
	return (loopbackIP);
}

/* Logs Utility */

void OKlogsEntry(const std::string& title, const std::string& str) {
	std::cout << BLUE << title << RESET << str << std::endl;
}

void ERRORlogsEntry(const std::string& title, const std::string& str) {
	std::cout << RED << title << RESET << str << std::endl;
}


=== ./src/main.cpp ===
#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include "Parsed.hpp"
#include "VirtualServersManager.hpp"
#include "DebugView.hpp"

void printSeparator(const std::string& title) {
    std::cout << "\n" << std::string(50, '=') << std::endl;
    std::cout << "  " << title << std::endl;
    std::cout << std::string(50, '=') << std::endl;
}


void testVirtualServersManager(const ParsedServers& configs) {
    printSeparator("TEST: VirtualServersManager");
    
    if (configs.empty()) {
        std::cout << "✗ No configurations to test" << std::endl;
        return;
    }
    
    try {
        VirtualServersManager manager(configs);
        
        std::cout << "✓ VirtualServersManager created" << std::endl;
        std::cout << "✓ Managing " << configs.size() << " servers" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "✗ Error creating manager: " << e.what() << std::endl;
    }
}

void runInteractiveTest(const ParsedServers& configs) {
    printSeparator("INTERACTIVE TEST");
    
    if (configs.empty()) {
        std::cout << "✗ No configurations for interactive test" << std::endl;
        return;
    }
    
    std::cout << "Starting interactive server test..." << std::endl;
    std::cout << "This will start all configured servers" << std::endl;
    
    // Show what will be started
    for (size_t i = 0; i < configs.size(); ++i) {
        for (size_t j = 0; j < configs[i].listens.size(); ++j) {
            std::cout << "  Server on " << configs[i].listens[j].host 
                      << ":" << configs[i].listens[j].port;
            if (!configs[i].server_names.empty()) {
                std::cout << " (" << configs[i].server_names[0] << ")";
            }
            std::cout << std::endl;
        }
    }
    
    std::cout << "\nStarting servers..." << std::endl;
    
    try {
        VirtualServersManager manager(configs);
        
        std::cout << "Starting all servers..." << std::endl;
        std::cout << "Press Ctrl+C to stop" << std::endl;
        
        // Start the actual event loop
        manager.run();
        
    } catch (const std::exception& e) {
        std::cout << "✗ Error running servers: " << e.what() << std::endl;
    }
}

int main(int argc, char* argv[]) {
    std::cout << "Webserv Test" << std::endl;
    std::cout << "============" << std::endl;
    
    // Flags & config filename preprocessing
    bool interactive = false;
    const char* configFilename = NULL;
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--interactive") {
            interactive = true;
        } else if (!arg.empty() && arg[0] == '-') {
            // ignore unknown flags for now
        } else if (configFilename == NULL) {
            configFilename = argv[i];
        }
    }

    // Parse configuration
    ParsedServers parsedConfig;

    try {
        MediaType::load_types();

        // Prepare for parseProcess function
        int newArgc = (configFilename ? 2 : 1);
        char* newArgv[3];
        newArgv[0] = argv[0];
        if (configFilename) newArgv[1] = const_cast<char*>(configFilename);
        int result = parseProcess(newArgc, newArgv, parsedConfig);
        
        if (result != 0) {
            Logger::getInstance().error("Configuration parsing failed");
            return 1;
        }
        
        if (parsedConfig.empty()) {
            Logger::getInstance().error("✗ No server configurations found");
            return 1;
        }
        
        Logger::getInstance().info("✓ Configuration parsed successfully");
        
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "✗ Error parsing configuration: " << e.what();
        Logger::getInstance().error(oss.str());
        return 1;
    }
    
    // DEBUG
    DebugView::printConfigSummary(parsedConfig);
        
    // Interactive test
    std::cout << "\nRun with config file for interactive testing" << std::endl;
    std::cout << "Example: ./webserver conf/test_simple.conf --interactive" << std::endl;

    if (interactive) {
        std::cout << "\nStarting servers interactively..." << std::endl;
        runInteractiveTest(parsedConfig);
        return 0; // if runInteractiveTest returns
    }

    return 0;
}

// TODO test location por defecto
=== ./src/Location.cpp ===
#include "Location.hpp"

Location::Location()
    : _path("/")
    , _match_type(PREFIX)  // ← AÑADIDO - esta era la causa del bug
    , _methods()
    , _root("")
    , _index("index.html")
    , _autoindex(AINDX_DEF_OFF)
    , _redirect("")
    , _cgi_extension("")
    , _allow_upload(false)  // ← AÑADIDO - faltaba
{
}

Location::Location(const Location& other)
    : _path(other._path)
    , _match_type(other._match_type)  // ← AÑADIDO - crítico para copy constructor
    , _methods(other._methods)
    , _root(other._root)
    , _index(other._index)
    , _autoindex(other._autoindex)
    , _redirect(other._redirect)
    , _cgi_extension(other._cgi_extension)
    , _allow_upload(other._allow_upload)  // ← AÑADIDO - faltaba
    , _error_pages(other._error_pages)    // ← AÑADIDO - faltaba
{
}

Location::~Location() {}

bool Location::matchesPath(const std::string& path) const {
    if (_path == "/")
        return true;
    
    if (path.find(_path) == 0)
        return (path.length() == _path.length() || path[_path.length()] == '/');

    return false;
}

std::string Location::getErrorPage(int error_code) const {
    std::map<int, std::string>::const_iterator it = _error_pages.find(error_code);
    if(it != _error_pages.end()) {
        return it->second;
    }
    return "";
}
=== ./src/http/HTTPMethod.cpp ===
#include "HTTPMethod.hpp"

std::ostream & operator<<(std::ostream & os, HTTPMethod method)
{
    switch (method)
    {
        case NOMETHOD: os << "No method"; break;
        case GET: os << "GET"; break;
        case POST: os << "POST"; break;
        case DELETE: os << "DELETE"; break;
        case PUT: os << "PUT"; break;
        default: os << "Method uninitialized"; break;
    }
    return os;
}

HTTPMethod method::str_to_method(std::string const & str)
{
    if (wss::casecmp(str, "GET"))
        return GET;
    else if (wss::casecmp(str, "POST"))
        return POST;
    else if (wss::casecmp(str, "DELETE"))
        return DELETE;
    else if (wss::casecmp(str, "PUT"))
        return PUT;
    else
        return NOMETHOD;
}

std::string const method::method_to_str(HTTPMethod const & m)
{
    switch (m)
    {
        case GET: return "GET";
        case POST: return "POST";
        case DELETE: return "DELETE";
        case PUT: return  "PUT";
        default: CODE_ERR("Trying to transform an unknown method to string");
    }
}

=== ./src/http/HTTPRequest.cpp ===
#include "HTTPRequest.hpp"

HTTPRequest::HTTPRequest(){}

void HTTPRequest::reset()
{
    body.reset();
    uri.reset();
    headers.reset();
    method = NOMETHOD;
    protocol = "";
}

std::string HTTPRequest::to_string()
{
    std::stringstream ss;

    print(ss);
    return ss.str();
}

void HTTPRequest::print(std::ostream & os) const
{
    os 
    << "METHOD: " << method << "\n"
    << "URI: " << uri << "\n"
    << "PROTOCOL: " << protocol << "\n"
    << "HEADERS: " << "\n" << headers
    << "BODY: " << body << "\n";
}

std::ostream & operator<<(std::ostream & os, const HTTPRequest &request)
{
    request.print(os);
    return os;
}

int HTTPRequest::get_port() const
{
    // Return port from URI, or default to 80 if not specified
    if (uri.port == 0)
        return 80;
    else
        return uri.port;
}

std::string const HTTPRequest::get_host() const
{
    // Try to get host from Host header first, then from URI
    std::map<std::string, std::string>::const_iterator it = headers.fields.find("Host");
    if (it != headers.fields.end())
    {
        std::string host_header = it->second;
        // Remove port from host header if present (host:port format)
        size_t colon_pos = host_header.find(':');
        if (colon_pos != std::string::npos)
            return host_header.substr(0, colon_pos);
        return host_header;
    }
    
    // Alternative: use the host field directly
    if (!headers.host.empty())
        return headers.host;
    
    // Fallback to URI host
    if (!uri.host.empty())
        return uri.host;
        
    // Default fallback
    return "localhost";
}

std::string const HTTPRequest::get_path() const
{
    if (uri.path.empty())
        return "/";
    else
        return uri.path;
}

=== ./src/http/HTTPBody.cpp ===
#include "HTTPBody.hpp"

HTTPBody::HTTPBody(){}

void HTTPBody::reset()
{
    content = "";
}


void HTTPBody::print(std::ostream & os) const
{
    os << content;
}

std::ostream & operator<<(std::ostream & os,  HTTPBody const & line)
{
    line.print(os);
    return os;
}
=== ./src/http/RequestValidator.cpp ===
#include "RequestValidator.hpp"

void RequestValidator::put_error(std::string const & text, Status status)
{
    if (_error.status() != OK)
    {
        Logger::getInstance().warning("Found more than one error, will be logged and ignored. " + status::status_to_text(status) + " " + text + ". Actual: " + _error.to_string());
        return ;
    }
    _error.set(text, status);
}

HTTPError const * RequestValidator::error(){return &_error;}

RequestValidator::RequestValidator(HTTPRequest & request, HTTPError & error):_request(request), _error(error){}


void RequestValidator::validate_method(HTTPMethod const & method)
{
    if (method == NOMETHOD)
        return put_error("Request method not implemented", NOT_IMPLEMENTED);

}

void RequestValidator::validate_protocol(std::string const & protocol)
{
    if (protocol != "HTTP/1.1")
        return put_error("Invalid protocol: " + protocol + " only HTTP/1.1 supported", VERSION_NOT_SUPPORTED);
}

    
void RequestValidator::validate_first_line(HTTPRequest const & request)
{
    validate_protocol(request.protocol);
    if (_error.status() == OK) {validate_uri(request.uri);}
    if (_error.status() == OK) {validate_method(request.method);}
}

void RequestValidator::validate_uri(URI const & uri)
{
    if (uri.schema != "" && uri.schema != "http")
        _error.set("Protocol not implemented: " + uri.schema, NOT_IMPLEMENTED);
}


void RequestValidator::validate_headers(HTTPRequest const & request, FieldSection const & hdr)
{
    (void) request;
    
    std::map<std::string, std::string>::const_iterator host = hdr.fields.find("host");

    // Host header validation
    if (host == hdr.fields.end())
        return put_error("The header section must contain a host header field", BAD_REQUEST);

    if (host->second.find(',') != std::string::npos)
        return put_error("The host header must be a single value", BAD_REQUEST);
    
    // if (!request.uri.host.empty() && (request.uri.host != hdr.host || request.uri.port != hdr.port))
    //      return put_error("The authority component on URI is different from the header's authority", BAD_REQUEST);


    // Validate transfer encodings
    for (std::vector<Coding>::const_iterator it = hdr.transfer_encodings.begin(); it != hdr.transfer_encodings.end(); it ++)
    {
        if (it->name != "chunked")
             return put_error("Not implemented Transfer-Encoding: " + it->name, NOT_IMPLEMENTED);
        else
        {
            if (it + 1 != hdr.transfer_encodings.end())
                return put_error("Transfer-Encoding: chunked must be last", BAD_REQUEST);
            if (!it->parameters.empty())
                return put_error("Transfer-Encoding: chunked can't have parameters", BAD_REQUEST);
            if (hdr.fields.find("content-length") != hdr.fields.end())
                return put_error("Transfer-Encoding and Content-Length are incompatible", BAD_REQUEST);
        }
    }

    // Validate Connection
    for (std::vector<std::string>::const_iterator it = hdr.connections.begin(); it != hdr.connections.end(); it ++)
        if (*it == "close")
            _request.headers.close_status = RCS_CLOSE;
        
    // Validate expectations
    for (std::vector<std::string>::const_iterator it = hdr.expectations.begin(); it != hdr.expectations.end(); it ++)
        if (*it != "100-continue")
            return put_error("Only expectation allowed is '100-continue'", EXPECTATION_FAILED);
  
    // Validate Content-Type
    if (_request.method == POST)
    {
        if (_request.headers.fields.find("content-type") == _request.headers.fields.end())
        {
            _request.headers.content_type.type = "application";
            _request.headers.content_type.subtype = "octet-stream";
        }

        t_mime_conf::iterator it;
        for (it = MediaType::ACCEPTED_TYPES.begin(); it != MediaType::ACCEPTED_TYPES.end(); it ++)
        {
            if (wss::casecmp(it->first.type, _request.headers.content_type.type) && wss::casecmp(it->first.subtype, _request.headers.content_type.subtype))
            {
                validate_extensions(_request.get_path(), it->second);
                break ;
            }
        }
        if (it == MediaType::ACCEPTED_TYPES.end())
            return put_error("Unsupported media type " + _request.headers.content_type.type + "/" + _request.headers.content_type.subtype, UNSUPPORTED_MEDIA_TYPE);
    }
}

bool RequestValidator::validate_extension(std::string const & filename, std::string const & extension)
{
    std::cout<< "VALIDATE: " << filename << " " << extension << std::endl;
    return wss::casecmp(filename, filename.size() - extension.size(), extension.size(), extension);
}

void RequestValidator::validate_extensions(std::string const & filename, std::vector<std::string> const & extensions)
{
    std::vector<std::string>::const_iterator it;
    for (it = extensions.begin(); it != extensions.end() && _error.status() == OK; it ++)
        if (validate_extension(filename, *it))
            break ;
    if (it == extensions.end() && !extensions.empty())
        _error.set("Mismatch between Content-Type and extension", BAD_REQUEST);
}


void RequestValidator::validate_body(HTTPBody const & body)
{
    (void)body; // Suppress unused parameter warning
}


=== ./src/http/FieldSection.cpp ===
#include "FieldSection.hpp"
#include "ParsingUtil.hpp"
#include "StringUtil.hpp"

FieldSection::FieldSection(){reset();}

void FieldSection::reset()
{
    port = -1;
    host = "";
    content_length = -1;
    fields.clear();
    transfer_encodings.clear();
    connections.clear();
    cookies.clear();
    expectations.clear();
    content_type.reset();
    close_status = RCS_KEEP_ALIVE;
}

void FieldSection::put(std::string const & str, std::string const & value)
{
    if (fields.find(str) == fields.end())
        fields[str] = value;
    else
        fields[str] += ", " + value;
}

void FieldSection::print(std::ostream & os) const
{
    for (std::map<std::string, std::string>::const_iterator it = fields.begin(); it != fields.end(); it ++)
        os << "\t" << it->first << ": "  << it->second << std::endl;
    os << "\tHeader parsed data... "
    << " port: " << port
    << " host: " << host
    << " content-length: " << content_length;

    for (std::vector<Coding>::const_iterator it = transfer_encodings.begin(); it != transfer_encodings.end(); it ++)
    {
        os << it->name << " ";
        for (std::vector<std::pair<std::string, std::string> >::const_iterator params = it->parameters.begin(); params != it->parameters.end(); params ++)
        {
            os << "param: " << params->first << "=" << params->second;
            if (params + 1 != it->parameters.end())
                os << "; ";
        }
        if (it + 1 != transfer_encodings.end())
            os << ", ";
    }

    if (transfer_encodings.size() > 0)
    {
        os << "\n\ttransfer-encodings: ";
        for (std::vector<Coding>::const_iterator it = transfer_encodings.begin(); it != transfer_encodings.end(); it ++)
        {
            os << it->name << " ";
            for (std::vector<std::pair<std::string, std::string> >::const_iterator params = it->parameters.begin(); params != it->parameters.end(); params ++)
            {
                os << "param: " << params->first << "=" << params->second;
                if (params + 1 != it->parameters.end())
                    os << "; ";
            }
            if (it + 1 != transfer_encodings.end())
                os << ", ";
        }
    }
    if (cookies.size() > 0)
    {
        os << "\n\tCookies: ";
        for (std::map<std::string, std::string>::const_iterator it = cookies.begin(); it != cookies.end(); it ++)
        {
            os << it->first << "=" << it->second;
            std::map<std::string, std::string>::const_iterator next = it;
            next ++;
            if (next != cookies.end())
                os << "; ";
        }
    }
    if (expectations.size() > 0)
    {
        os << "\n\tExpectations: ";
        for (std::vector<std::string>::const_iterator it = expectations.begin(); it != expectations.end(); it ++)
        {
            os << *it;
            if (it + 1 != expectations.end())
                os << ", ";
        }
    }
    if (expectations.size() > 0)
    {
        os << "\n\tConnections: ";
        for (std::vector<std::string>::const_iterator it = connections.begin(); it != connections.end(); it ++)
        {
            os << *it;
            if (it + 1 != connections.end())
                os << ", ";
        }
    }
   if (content_type.type != "")
    {
        os << "\n\tcontent-type: " << content_type.type << "/" << content_type.subtype << "; ";
        for (std::vector<std::pair<std::string, std::string> >::const_iterator params = content_type.parameters.begin(); params != content_type.parameters.end(); params ++)
        {
            os << params->first << "=" << params->second;
            if (params + 1 != content_type.parameters.end())
                os << "; ";
        }
    }

    os << std::endl;
}


void FieldSection::put_cookie(std::string::iterator name_start, std::string::iterator name_end, std::string::iterator value_start, std::string::iterator value_end)
{
    cookies[std::string(name_start, name_end)] = std::string(value_start, value_end);   
}

std::ostream & operator<<(std::ostream & os,  FieldSection const & header)
{
    header.print(os);
    return os;
}

=== ./src/http/URI.cpp ===
#include "URI.hpp"

URI::URI()
{reset();}

void URI::reset()
{
    host = "";
    path = "";
    query = "";
    fragment = "";
    port = -1;
    schema = "";
    length = 0;
}

void URI::print(std::ostream & os) const
{
    os << "\n"
    << "\tSCHEMA: " << schema << ", "
    << "HOST: " << host << ", "
    << "PORT: " << port << ", "
    << "PATH: " << path << ", "
    << "QUERY: " << query << ", "
    << "FRAGMENT: " << fragment
    ;
}

std::ostream & operator<<(std::ostream & os,  URI const & uri)
{
    uri.print(os);
    return os;
}
=== ./src/http/HTTPError.cpp ===
#include "HTTPError.hpp"

HTTPError::HTTPError(std::string const & motive, Status status) :_motive(motive), _status(status){}

HTTPError::HTTPError(){_status = OK;}

Status HTTPError::status() const {return _status;}

void HTTPError::log() const {Logger::getInstance().error(status::status_to_text(_status) + ": "   + _motive);}

std::string const HTTPError::to_string() const {return status::status_to_text(_status) + ": "   + _motive;}

void HTTPError::set(std::string const & motive, Status status){_motive = motive; _status = status;}

std::string const & HTTPError::msg() const{return _motive;}

=== ./src/maintest.cpp ===

// REQUEST TEST


/*
    Use this to test Responses or CGI. Modify file 'request_test.txt'
    If the requests hangs is because it's not finished (For example, forgetting a LF after the headers)
*/

#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include <fcntl.h>
#include <errno.h>
#include "HTTPRequest.hpp"
#include "RequestManager.hpp"
#include "ResponseManager.hpp"
#include "SysBufferFactory.hpp"

void generate_rq_response(ResponseManager & responseManager)
{
	responseManager.generate_response();
	while (1)
	{
		// responseManager.get_active_file_descriptor();
		responseManager.process();
		if (responseManager.response_done())
			break ;
	}
}

int main(int argc, char ** argv){
    int f = open("default.conf", O_RDONLY | O_NONBLOCK);
    int fr = open("response_test.txt", O_WRONLY | O_NONBLOCK | O_CREAT | O_TRUNC, 0777);

	if (f <= 0)
	{
		perror("default.conf");
		return 1;
	}

	HTTPError err;
    HTTPRequest request;
    RequestManager requestmanager(request, err, SysBufferFactory::SYSBUFF_FILE, f);
	ResponseManager responsemanager(request, err, SysBufferFactory::SYSBUFF_FILE, fr);

    while (1)
    {
        requestmanager.process();
        if (requestmanager.gerError().status() != OK || requestmanager.request_done())
		{
			generate_rq_response(responsemanager);
            break ;
		}
    }
}
=== ./src/ConfigInheritance.cpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigInheritance.cpp                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/16 16:41:04 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 20:18:04 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ConfigInheritance.hpp"

void applyAutoindex(ParsedServer& server)
{
	for (std::map<std::string, Location>::iterator it = server.locations.begin();
		 it != server.locations.end(); ++it)
	{
		if (it->second.getAutoindex() == AINDX_DEF_OFF)
		{
			it->second.setAutoindex(server.autoindex);
		}
	}
}

void applyAllowMethods(ParsedServer& server)
{
	if (server.allow_methods.empty())
		server.allow_methods.push_back("GET");

	for (std::map<std::string, Location>::iterator it = server.locations.begin();
         it != server.locations.end(); ++it)
	{
		std::vector<std::string> methods = it->second.getMethods();

		if (methods.empty())
		{
			it->second.setMethods(server.allow_methods);
		}
	}
}


=== ./src/util/StringUtil.cpp ===
#include "StringUtil.hpp"

void wss::to_upper(std::string & s)
{
    for(std::string::iterator it = s.begin(); it != s.end(); it ++)
        *it = std::toupper(*it);
}
void wss::to_lower(std::string & s)
{
    for(std::string::iterator it = s.begin(); it != s.end(); it ++)
        *it = std::tolower(*it);
}

void wss::trim(std::string & s)
{
    if (s.empty())
        return;

    std::string::iterator begin = s.begin();
    std::string::iterator end = s.end() - 1;

    while (begin != s.end() && parse::is_whitespace(*begin))
        begin++;
    while (end >= begin && parse::is_whitespace(*end))
        end--;
    s = std::string(begin, end + 1);
}

std::string::iterator wss::skip_ascii_whitespace(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_ascii_whitespace(*begin)) begin ++; 
    return begin;
}

std::string::iterator wss::skip_whitespace(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && (*begin == ' '|| *begin == '\t')) begin ++; 
    return begin;
}

std::string::iterator wss::skip_ascii_whitespace_r(std::string::iterator end, std::string::iterator begin)
{
    end --;
    while(begin != end && parse::is_ascii_whitespace(*end)) end --; 
    return end + 1;
}

std::string::iterator wss::skip_http_token(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_token_char(*begin)) begin ++;
    return begin;
}

std::string::iterator wss::skip_uri_token(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_uri_char(*begin)) begin ++;
    return begin;  
}

std::string::iterator wss::skip_protocol_token(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_protocol_char(*begin)) begin ++;
    return begin;  
}

std::string::iterator wss::skip_path_rootless(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_pchar(*begin)) begin ++;
    return skip_absolute_path(begin, end);
}

std::string::iterator wss::skip_absolute_path(std::string::iterator begin, std::string::iterator end)
{
    while (begin != end && *begin == '/')
    {
        begin ++;
        while(begin != end && parse::is_pchar(*begin)) begin ++;   
    }
    return begin;
}

 std::string::iterator wss::skip_host_token(std::string::iterator begin, std::string::iterator end)
{
    while (begin != end && parse::is_host_char(*begin)) begin ++;
    return begin;
}

std::string::iterator wss::skip_port_token(std::string::iterator begin, std::string::iterator end)
{
    begin ++;
    while (begin != end && parse::is_digit(*begin)) begin ++;
    return begin;
}

std::string::iterator wss::skip_query_token(std::string::iterator begin, std::string::iterator end)
{
    begin ++;
    while (begin != end && parse::is_query_char(*begin)) begin ++;
    return begin;
}

std::string::iterator wss::skip_fragment_token(std::string::iterator begin, std::string::iterator end)
{
    begin ++;
    while (begin != end && parse::is_fragment_char(*begin)) begin ++;
    return begin;
}

std::string::iterator wss::skip_schema_token(std::string::iterator begin, std::string::iterator end)
{
    while(begin != end && parse::is_alpha(*begin)) begin ++;
    return begin;
}

// S.f if sizeof(s) < n, or it + n >= str.end()
bool wss::str_equal(std::string::iterator it, size_t n, const char *s)
{
    for (size_t i = 0; i < n; i++)
        if (*(it + i) != s[i])
            return false;
    return true;
}

// S.f if it + n >= str.end()
bool wss::str_equal(std::string::iterator it, const char *s)
{
    for (int i = 0; s[i]; i++)
        if (*(it + i) != s[i])
            return false;
    return true;
}
 
void wss::remove_uri_segment(std::string & out)
{
    if (out.empty())
        return;

    std::string::iterator end = out.end() - 1;
    while (end != out.begin() && *end == '/')
        end --;
    while (end != out.begin() && *end != '/')
        end --;
    if (end == out.begin() && *end != '/')
        out.clear();
    else
        out = std::string(out.begin(), end);  
}

std::string::iterator wss::move_uri_segment(std::string & dst, std::string & src, std::string::iterator begin)
{
    std::string::iterator end = begin;
    if (end != src.end() && *end == '/')   
        end ++;
    while (end != src.end() && *end != '/')
        end ++;
    dst.insert(dst.end(), begin, end);
    return end;
}

std::string::iterator wss::skip_until(std::string::iterator begin, std::string::iterator end, std::string const & str)
{
    while (begin != end && str.find(*begin) == std::string::npos)
        begin ++;
    return begin;
}

std::string::iterator wss::skip_until_dquoted_string_end(std::string::iterator begin, std::string::iterator end)
{
    while (begin != end && *begin != '"')
    {
        if (*begin == '\\' && begin + 1 != end)
            begin ++;
        begin ++;
    }
    return begin;
}

std::string::iterator wss::skip_hexa_token(std::string::iterator begin, std::string::iterator end)
{
    while (begin != end && parse::is_hexa_char(*begin))
        begin ++;
    return begin;
}

bool wss::casecmp(std::string const & s1, std::string const & s2)
{
    if (s1.size() != s2.size())
        return false;
    for (size_t i = 0; i < s1.size(); ++i)
        if (tolower(s1[i]) != tolower(s2[i]))
            return false;
    return true;
}

bool wss::casecmp(std::string const & s1, size_t pos, size_t len, std::string const & s2)
{
    if (pos + len > s1.size() || s2.size() < len)
        return false;
    for (size_t i = 0; i < len; ++i)
    {
        if (std::tolower(s1[pos + i]) != std::tolower(s2[i]))
            return false;
    }
    return true;
}

std::string wss::i_to_hex(size_t size)
{
    std::string res;

    while (size > 0)
    {
        res.push_back(parse::byte_char_to_hex(size % 16));
        size /= 16;
    }
    std::reverse(res.begin(), res.end());
    return res.empty() ? "0" : res;
}

std::string wss::ui_to_dec(ssize_t size)
{
    bool ng = false;
    std::string res;

    if (size < 0)
    {
        ng = true;
        size *= -1;
    }
    while (size > 0)
    {
        res.push_back(parse::byte_char_to_hex(size % 10));
        size /= 10;
    }
    if (ng)
        res.push_back('-');
    std::reverse(res.begin(), res.end());
    return res.empty() ? "0" : res;
}

std::string wss::i_to_dec(size_t size)
{
    std::string res;

    while (size > 0)
    {
        res.push_back(parse::byte_char_to_hex(size % 10));
        size /= 10;
    }
    std::reverse(res.begin(), res.end());
    return res.empty() ? "0" : res;
}
=== ./src/util/DebugView.cpp ===
#include "DebugView.hpp"
#include "Utils.hpp"

static void printLine(const std::string &s, size_t width) {
    std::string line = s;
    if (line.size() > width) line = line.substr(0, width);
    if (line.size() < width) line += std::string(width - line.size(), ' ');
    Logger &log = Logger::getInstance();
    log.info("| " + line + " |");
}

void DebugView::printBox(const std::string &title, const std::vector<std::string> &lines) {
    Logger &log = Logger::getInstance();
    const size_t width = 66; // interior width
    const std::string top = "+" + std::string(width + 2, '=') + "+"; // +==...==+
    log.info(top);
    std::string titleLine = "[ " + title + " ]";
    if (titleLine.size() > width) titleLine = titleLine.substr(0, width);
    if (titleLine.size() < width) titleLine += std::string(width - titleLine.size(), ' ');
    log.info("| " + titleLine + " |");
    log.info(top);
    for (size_t i = 0; i < lines.size(); ++i) {
        printLine(lines[i], width);
    }
    log.info(top);
}

void DebugView::printConfigSummary(const ParsedServers &configs) {
    std::cout << "PRINT CONFIG SUMMARY" << std::endl;
    std::vector<std::string> lines;
    lines.push_back("servers: " + wss::i_to_dec(configs.size()));
    for (size_t i = 0; i < configs.size(); ++i) {
        const ParsedServer &srv = configs[i];
        // Header line per server
        std::string header = "srv " + wss::i_to_dec(i + 1) + " | listens: " + wss::i_to_dec(srv.listens.size());
        lines.push_back(header);

        // Each listen
        for (size_t j = 0; j < srv.listens.size(); ++j) {
            const Listen &l = srv.listens[j];
            std::string is_def = l.is_default ? " default" : "";
            lines.push_back("  - listen " + l.host + ":" + wss::i_to_dec(l.port) + is_def);
        }

        // Names (compact)
        if (!srv.server_names.empty()) {
            std::string names = "  names: ";
            for (size_t k = 0; k < srv.server_names.size(); ++k) {
                names += srv.server_names[k];
                if (k + 1 < srv.server_names.size()) names += ",";
            }
            lines.push_back(names);
        } else {
            lines.push_back("  names: -");
        }

        // Root, index count, methods count, locations count
        lines.push_back("  root: " + (srv.root.empty() ? std::string("-") : srv.root));
        lines.push_back("  index: " + wss::i_to_dec(srv.index_files.size()));

        lines.push_back("  methods: " + wss::i_to_dec(srv.allow_methods.size()));
        std::vector<std::string>::const_iterator m_it = srv.allow_methods.begin();
        for (;m_it != srv.allow_methods.end(); ++m_it) {
            lines.push_back("      allowed method: '" + *m_it + "'");
        }

        lines.push_back("  locations: " + wss::i_to_dec(srv.locations.size()));
        std::map<std::string, Location>::const_iterator l_it = srv.locations.begin();
        for (;l_it != srv.locations.end(); ++l_it) {
            lines.push_back("      location path value: '" + l_it->first + "'");
        }
    }

    printBox("CONFIG SUMMARY", lines);
}



=== ./src/util/Logger.cpp ===
#include "Logger.hpp"
#include "HTTPRequest.hpp"

const std::string Logger::RED = "\033[1;91m";
const std::string Logger::GREEN = "\033[1;92m";
const std::string Logger::YELLOW = "\033[1;93m";
const std::string Logger::BLUE = "\033[1;94m";
const std::string Logger::RESET = "\033[0m";
const std::string Logger::ERR_PREFIX = RED + "Error. " + RESET;
const std::string Logger::WAR_PREFIX = YELLOW + "Warning. " + RESET;
const std::string Logger::INFO_PREFIX = BLUE + "Information. " + RESET;
const std::string Logger::DEBUG_PREFIX = GREEN + "Debug. " + RESET;

Logger::Logger(LogLevel log_level)
:_log_level(log_level),
_information_output(&std::cout),
_warning_output(&std::cout),
_error_output(&std::cerr)
{}

Logger::~Logger(){}

Logger & Logger::getInstance()
{
    static Logger instance(DEBUG); 
    return instance;
}

void Logger::info(std::string const & str) const
{
    if (_log_level == DEBUG || 
        _log_level == INFORMATION)
    {
        std::ostream * os = _information_output;
        _output_timestamp(os);
        *os << Logger::INFO_PREFIX << str << std::endl;
    }
}

void Logger::warning(std::string const & str) const
{
    if (_log_level == DEBUG || 
        _log_level == INFORMATION || 
        _log_level == WARNING)
    {
        std::ostream * os = _warning_output;
        _output_timestamp(os);
        *os << Logger::WAR_PREFIX << str << std::endl;
    }
}

void Logger::error(std::string const & str) const
{
    std::ostream * os = _error_output;
    _output_timestamp(os);
    *os << Logger::ERR_PREFIX << str << std::endl;
}

void Logger::setLogLevel(LogLevel log_level)
{
    _log_level = log_level;
}

void Logger::setOutput(LogLevel log_level, std::string const & str)
{
    std::ofstream os(str.c_str());
    if (os.fail())
        throw std::runtime_error("Can't open Logger output file");
    setOutput(log_level, os);
}

void Logger::setOutput(LogLevel log_level, std::ostream & os)
{
    switch (log_level)
    {
        case INFORMATION: _information_output = &os; return;
        case WARNING: _warning_output = &os ; return;
        case ERROR: _error_output = &os; return;
        default:
            throw std::runtime_error("Unknown log level type");
    }
}

void Logger::_output_timestamp(std::ostream * os) const
{
    time_t timestamp;
    time(&timestamp);
    char *str = ctime(&timestamp);
    str[std::strlen(str) - 1] = 0;
    *os << "[" << str << "] ";
}

std::ostream & Logger::operator<<(std::string const & str)
{
    _output_timestamp(_information_output);
    *_information_output << DEBUG_PREFIX << str;
    return *_information_output;
}

std::ostream & Logger::operator<<(HTTPRequest const & header)
{
    _output_timestamp(_information_output);
    *_information_output << DEBUG_PREFIX << header;
    return *_information_output;
}

=== ./src/util/ParsingUtil.cpp ===
#include "ParsingUtil.hpp"
#include <cstring>

bool parse::is_digit(char c)
{return isdigit(c);}

bool parse::is_alpha(char c)
{return isalpha(c);}


bool parse::is_vchar(char c)
{return c >= 0x21 && c <= 0x7E;}

bool parse::is_whitespace(char c)
{return strchr(" \t", c);}

bool parse::is_unreserved(char c)
{return strchr("-._~", c) || is_alpha(c) || is_digit(c);}


bool parse::is_sub_delim(char c)
{return strchr("!$&'()*+,;=", c);}

bool parse::is_protocol_char(char c)
{return is_digit(c) || is_alpha(c) || c == '/' || c == '.';}

bool parse::is_pchar(char c)
{return strchr(":@%", c) || is_sub_delim(c) || is_unreserved(c);}

bool parse::is_token_char(char c)
{
    return  is_digit(c) || is_alpha(c) || strchr("!#$%&\'*+-.^_`|~", c);
}

bool parse::is_uri_char(char c)
{
    return strchr("/?#", c) || is_digit(c) || is_alpha(c) || is_pchar(c);
}

bool parse::is_token(std::string const & str)
{
    if (str.length() == 0)
        return false;
    for (std::string::const_iterator it = str.begin(); it != str.end(); it ++)
        if (!is_token_char(*it))
            return false;
    return true;
}

bool parse::is_host_char(char c)
{return strchr(".%", c) || is_sub_delim(c) || is_unreserved(c);}


bool parse::is_fragment_char(char c)
{
    return parse::is_pchar(c) || c == '/' || c == '?';
}

bool parse::is_query_char(char c)
{
    return parse::is_pchar(c) || c == '/' || c == '?';
}

bool parse::is_ascii_whitespace(char c)
{
    return strchr(" \t\v\r\f" , c);
}

bool parse::is_field_value_char(char c)
{
    return is_vchar(c) || c < 0 || c == ' ' || c == '\t';
}

void parse::first_line_sanitize(std::string::iterator begin, std::string::iterator end)
{
    for (std::string::iterator it = begin; it != end; it ++)
        if (parse::is_ascii_whitespace(*it))
            *it = ' ';
}

void parse::sanitize_header_value(std::string::iterator start, std::string::iterator end)
{
    for (;start != end; start ++)
        if (parse::is_ascii_whitespace(*start) || (*start < 32 && *start >= 0))
            *start = ' ';
}

bool parse::is_hexa_char(char c)
{
    return (is_digit(c) || strchr("ABCDEF", std::toupper(c)));
}


bool parse::is_obs_text_char(char c)
{
    return  (unsigned char) c >= 0x80;
}

bool parse::is_qdtext_char(char c)
{
    return  strchr(" \t!" , c) || (c >= 0x23 && c <= 0x5b)  || (c >= 0x5d && c <= 0x7e) || is_obs_text_char(c);
}

bool parse::is_quoted_pair_char(char c)
{
    return is_vchar(c) || strchr(" \t" , c) || is_obs_text_char(c);
}

bool parse::is_cookie_char(char c)
{
    return  (c == 0x21) || \
            (c >= 0x23 && c <= 0x2b) || \
            (c >= 0x2d && c <= 0x3a) || \
            (c >= 0x3c && c <= 0x5b) || \
            (c >= 0x5d && c <= 0x7e);
}

char parse::hex_to_byte(char c)
{
    if (is_digit(c))
        return c - '0';
    else
        return std::toupper(c) - 'A' + 10;
}

char parse::byte_char_to_hex(int c)
{
    if (c > 15)
        throw std::runtime_error("Converting a byte to hexa, but it's too big (>15)");
    
    if (c < 10)
        return c + '0';
    else
        return c + 'A';
}

// max = 0 is no max. Use a max that would not overflow on size_t boundaries
size_t parse::s_to_hex(std::string::iterator start, std::string::iterator end, size_t max)
{
    size_t n = 0;

    while (start != end)
    {
        size_t val = hex_to_byte(*start);
        if (max > 0 && n > (max - val) / 16)
            return max;
        n = n*16 + val;
        start ++;
    }
    return n;
}

=== ./src/util/Status.cpp ===
#include "Status.hpp"

namespace status
{
std::string const & status_to_text(Status const & status) 
{
    static const std::string ok = "Ok (200)";
    static const std::string bad_request = "Bad Request (400)";
    static const std::string forbidden = "Forbidden (403)";
    static const std::string not_found = "Not found (404)";
    static const std::string method_not_allowed = "Method not allowed (405)";
    static const std::string content_too_large = "Content Too Large (413)";
    static const std::string uri_too_long = "URI Too Long (414)";
    static const std::string expectation_failed = "Expectation failed (417)";
    static const std::string unsupported_media_type = "Unsupported Media-Type (415)";
    static const std::string request_header_too_large = "Request Header Fields Too Large (431)";
    static const std::string internal_server_error = "Internal Server Error (500)";
    static const std::string not_implemented = "Not Implemented (501)";
    static const std::string version_not_supported = "HTTP Version Not Supported (505)";
    static const std::string unknown = "UNKNOWN STATUS";

    switch (status)
    {
        case OK: return ok;
        case BAD_REQUEST: return bad_request;
        case FORBIDDEN: return forbidden;
        case NOT_FOUND: return not_found;
        case METHOD_NOT_ALLOWED: return method_not_allowed;
        case CONTENT_TOO_LARGE: return content_too_large;
        case URI_TOO_LONG: return uri_too_long;
        case EXPECTATION_FAILED: return expectation_failed;
        case UNSUPPORTED_MEDIA_TYPE: return unsupported_media_type;
        case REQUEST_HEADER_FIELDS_TOO_LARGE: return request_header_too_large;
        case INTERNAL_SERVER_ERROR: return internal_server_error;
        case NOT_IMPLEMENTED: return not_implemented;
        case VERSION_NOT_SUPPORTED: return version_not_supported;
        default: return unknown;
    }
}

std::string const & stoa(Status const & status) 
{
    static const std::string ok = "200";
    static const std::string bad_request = "400";
    static const std::string forbidden = "403";
    static const std::string not_found = "404";
    static const std::string method_not_allowed = "405";
    static const std::string content_too_large = "413";
    static const std::string uri_too_long = "414";
    static const std::string expectation_failed = "417";
    static const std::string unsupported_media_type = "415";
    static const std::string request_header_too_large = "431";
    static const std::string internal_server_error = "500";
    static const std::string not_implemented = "501";
    static const std::string version_not_supported = "505";

    switch (status)
    {
        case OK: return ok;
        case BAD_REQUEST: return bad_request;
        case FORBIDDEN: return forbidden;
        case NOT_FOUND: return not_found;
        case METHOD_NOT_ALLOWED: return method_not_allowed;
        case CONTENT_TOO_LARGE: return content_too_large;
        case URI_TOO_LONG: return uri_too_long;
        case EXPECTATION_FAILED: return expectation_failed;
        case UNSUPPORTED_MEDIA_TYPE: return unsupported_media_type;
        case REQUEST_HEADER_FIELDS_TOO_LARGE: return request_header_too_large;
        case INTERNAL_SERVER_ERROR: return internal_server_error;
        case NOT_IMPLEMENTED: return not_implemented;
        case VERSION_NOT_SUPPORTED: return version_not_supported;
        default: throw std::runtime_error("Trying to send an invalid status");
    }
}

StatusType status_type(Status const & status)
{
    switch (status)
    {
        case OK:
        case NO_STATUS:
            return STYPE_GENERATE_RESPONSE;
        case BAD_REQUEST:
        case CONTENT_TOO_LARGE:
        case URI_TOO_LONG:
        case REQUEST_HEADER_FIELDS_TOO_LARGE:
        case NOT_IMPLEMENTED:
        case VERSION_NOT_SUPPORTED:
        case EXPECTATION_FAILED:
        case UNSUPPORTED_MEDIA_TYPE:
        case FORBIDDEN:
        case NOT_FOUND:
        case METHOD_NOT_ALLOWED:
        case INTERNAL_SERVER_ERROR:
            return STYPE_IMMEDIATE_RESPONSE;
    }
    return STYPE_GENERATE_RESPONSE;
}

}

=== ./src/VirtualServersManager.cpp ===
#include "VirtualServersManager.hpp"
#include "StringUtil.hpp"
#include "Logger.hpp"
#include "DebugView.hpp"

// ================ STATIC MEMBER ================

std::map<int, VirtualServersManager::ClientState*> VirtualServersManager::ClientState::client_states;

// ================ CLIENT STATE IMPLEMENTATION ================

VirtualServersManager::ClientState::ClientState(int client_fd)
    : client_fd(client_fd)
    , element_parser(error)
    , request_manager(request, error, SysBufferFactory::SYSBUFF_SOCKET, client_fd)
    , response_manager(request, error, SysBufferFactory::SYSBUFF_SOCKET, client_fd)
{
    status = READING_REQUEST;
}

bool VirtualServersManager::ClientState::isRequestComplete() const {
    return request_manager.request_done();
}

bool VirtualServersManager::ClientState::hasError() const {
    return error.status() != OK;
}

VirtualServersManager::ClientState* VirtualServersManager::ClientState::getOrCreateClientState(int client_fd) {
    std::map<int, ClientState*>::iterator it = client_states.find(client_fd);
    if (it != client_states.end()) {
        return it->second;
    }

    ClientState* state = new ClientState(client_fd);
    client_states[client_fd] = state;
    return state;
}

void VirtualServersManager::ClientState::cleanupClientState(int client_fd) {
    std::map<int, ClientState*>::iterator it = client_states.find(client_fd);
    if (it != client_states.end()) {
        delete it->second;
        client_states.erase(it);
    }
}

void VirtualServersManager::ClientState::changeStatus(Status new_status, const std::string& reason) {
    Status old_status = status;
    status = new_status;

    std::ostringstream oss;
    oss << "Chanfe Client Status from " << old_status << " to " << status << " for " << client_fd << " because of: " << reason; 
    Logger::getInstance().info(oss.str());;
}

std::string VirtualServersManager::ClientState::statusToString(Status s) {
    switch(s) {
        case READING_REQUEST: return "READING_REQUEST";
        case PROCESSING_REQUEST: return "PROCESSING_REQUEST";
        case ERROR_HANDLING: return "ERROR_HANDLING";
        case WRITING_RESPONSE: return "WRITING_RESPONSE";
        case WAITING_FILE: return "WAITING_FILE";
        case WAITING_CGI: return "WAITING_CGI";
        case CLOSING: return "CLOSING";
        case CLOSED: return "CLOSED";
        default: return "UNKNOWN";
    }
}


// ================ LISTEN SOCKET IMPLEMENTATION ================

VirtualServersManager::ListenSocket::ListenSocket() {
    socket_fd = -1;
    listen_config = Listen();
}

VirtualServersManager::ListenSocket::ListenSocket(const Listen& config) {
    socket_fd = -1;
    listen_config = config;
}


// ================ CONSTRUCTORS & DESTRUCTOR ================

VirtualServersManager::VirtualServersManager() {
    _epoll_fd = -1;
    _events.resize(64);
}

VirtualServersManager::VirtualServersManager(const ParsedServers& configs) {
    _epoll_fd = -1;
    _events.resize(64);

    Logger::getInstance().info("Initializing VirtualServersManager with " + wss::i_to_dec(configs.size()) + " server configurations");
    _server_configs.reserve(configs.size() * 2);
    // TODO: agregar parse de allow_upload en ParsedServer, es necesario?
    // Procesar cada configuración parseada (C++98 compatible)
    for (std::vector<ParsedServer>::const_iterator parsed_it = configs.begin(); 
         parsed_it != configs.end(); ++parsed_it) {
        
        const ParsedServer& parsed_server = *parsed_it;
        
        Logger::getInstance().info("  Processing server with " + wss::i_to_dec(parsed_server.listens.size()) + " listen directives");
        
        // Crear ServerConfig a partir de ParsedServer
        ServerConfig server_config(parsed_server);
        _server_configs.push_back(server_config);
        
        // Obtener puntero al ServerConfig recién agregado (C++98 safe)
        ServerConfig* config_ptr = &_server_configs[_server_configs.size() - 1];
        
        // Procesar todas las directivas listen de este servidor
        for (std::vector<Listen>::const_iterator listen_it = parsed_server.listens.begin(); 
             listen_it != parsed_server.listens.end(); ++listen_it) {
            
            const Listen& listen_config = *listen_it;
            
            Logger::getInstance().info("    Mapping to " + listen_config.host + ":" + wss::i_to_dec(listen_config.port));
            
            // Agregar al mapeo de virtual hosts
            _virtual_hosts[listen_config].push_back(config_ptr);
            
            // Crear ListenSocket si no existe (C++98 compatible)
            if (_listen_sockets.find(listen_config) == _listen_sockets.end()) {
                ListenSocket new_socket(listen_config);
                _listen_sockets[listen_config] = new_socket;
                
                Logger::getInstance().info("    Created new ListenSocket for " + listen_config.host + ":" + wss::i_to_dec(listen_config.port));
            }
            
            // Agregar config al ListenSocket QUESTION: esta listo?
            std::map<Listen, ListenSocket>::iterator socket_it = _listen_sockets.find(listen_config);
            if (socket_it != _listen_sockets.end()) {
                socket_it->second.virtual_hosts.push_back(config_ptr);
            }
        }
    }
    
    Logger::getInstance().info("Virtual hosts mapping completed:");
    Logger::getInstance().info("  Total ServerConfigs: " + wss::i_to_dec(_server_configs.size()));
    Logger::getInstance().info("  Total Listen addresses: " + wss::i_to_dec(_listen_sockets.size()));
    Logger::getInstance().info("  Total Virtual host groups: " + wss::i_to_dec(_virtual_hosts.size()));
}

VirtualServersManager::~VirtualServersManager() {
    Logger::getInstance().info("Destroying VirtualServersManager...");
    
    // Limpiar map de client_fd to listen_socket
    _client_to_listen_socket.clear();

    // Cerrar epoll
    if (_epoll_fd >= 0) {
        close(_epoll_fd);
        Logger::getInstance().info("  Closed epoll fd: " + wss::i_to_dec(_epoll_fd));
    }
    
    // Cerrar todos los sockets de escucha
    for (std::map<Listen, ListenSocket>::iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        
        if (it->second.socket_fd >= 0) {
            close(it->second.socket_fd);
            Logger::getInstance().info("  Closed socket fd: " + wss::i_to_dec(it->second.socket_fd) + " for " + it->first.host + ":" + wss::i_to_dec(it->first.port));
        }
    }
    
    // Limpiar estados de clientes
    for (std::map<int, ClientState*>::iterator client_it = ClientState::client_states.begin();
         client_it != ClientState::client_states.end(); ++client_it) {
        delete client_it->second;
    }
    ClientState::client_states.clear();
    
    Logger::getInstance().info("VirtualServersManager destroyed.");
}

// ================ SOCKET MANAGEMENT ================

void VirtualServersManager::createListenSockets() {
    Logger::getInstance().info("Creating listen sockets...");
    
    for (std::map<Listen, ListenSocket>::iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        
        Logger::getInstance().info("Setting up socket for " + it->first.host + ":" + wss::i_to_dec(it->first.port));
        
        try {
            setupListenSocket(it->second);
            bindListenSocket(it->second);
            
            Logger::getInstance().info("Socket " + wss::i_to_dec(it->second.socket_fd) + " created for " + it->first.host + ":" + wss::i_to_dec(it->first.port) + " with " + wss::i_to_dec(it->second.virtual_hosts.size()) + " virtual hosts");
                      
        } catch (const std::exception& e) {
            std::ostringstream oss;
            oss << e.what() << " for " << it->first.host << ":" << it->first.port;
            Logger::getInstance().error(oss.str());
            throw;
        }
    }
}

void VirtualServersManager::setupListenSocket(ListenSocket& listen_socket) {
    listen_socket.socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket.socket_fd < 0) {
        throw std::runtime_error("Failed to create socket");
    }
    
    int opt = 1;
    if (setsockopt(listen_socket.socket_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        close(listen_socket.socket_fd);
        throw std::runtime_error("Failed to set socket options");
    }
}

void VirtualServersManager::bindListenSocket(ListenSocket& listen_socket) {
    struct sockaddr_in address;
    std::memset(&address, 0, sizeof(address));
    
    address.sin_family = AF_INET;
    address.sin_port = htons(listen_socket.listen_config.port);
    
    if (listen_socket.listen_config.host == "0.0.0.0" || listen_socket.listen_config.host.empty()) {
        address.sin_addr.s_addr = INADDR_ANY;
    } else {
        if (inet_pton(AF_INET, listen_socket.listen_config.host.c_str(), &address.sin_addr) <= 0) {
            close(listen_socket.socket_fd);
            throw std::runtime_error("Invalid host address: " + listen_socket.listen_config.host);
        }
    }
    
    if (bind(listen_socket.socket_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
        close(listen_socket.socket_fd);
        throw std::runtime_error("Failed to bind socket to " + listen_socket.listen_config.host + 
                                ":" + wss::i_to_dec(listen_socket.listen_config.port));
    }
    
    if (listen(listen_socket.socket_fd, 128) < 0) {
        close(listen_socket.socket_fd);
        throw std::runtime_error("Failed to listen on socket");
    }
}

void VirtualServersManager::setupEpoll() {
    Logger::getInstance().info("Setting up epoll...");
    
    _epoll_fd = epoll_create(1);
    if (_epoll_fd < 0) {
        throw std::runtime_error("Failed to create epoll fd");
    }
    
    createListenSockets();
    
    // Agregar todos los sockets de escucha a epoll
    for (std::map<Listen, ListenSocket>::iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        
        struct epoll_event event;
        event.events = EPOLLIN;
        event.data.fd = it->second.socket_fd;
        
        if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, it->second.socket_fd, &event) < 0) {
            throw std::runtime_error("Failed to add listen socket to epoll");
        }
    }
    
    Logger::getInstance().info("Epoll configured with " + wss::i_to_dec(_listen_sockets.size()) + " listen sockets");
}

// ================ SEARCH METHODS ================

bool VirtualServersManager::isListenSocket(int fd) const {
    for (std::map<Listen, ListenSocket>::const_iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        if (it->second.socket_fd == fd) {
            return true;
        }
    }
    return false;
}

VirtualServersManager::ListenSocket* VirtualServersManager::findListenSocket(int fd) {
    for (std::map<Listen, ListenSocket>::iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        if (it->second.socket_fd == fd) {
            return &it->second;
        }
    }
    return NULL;
}

// ================ EVENT HANDLING ================

void VirtualServersManager::handleEvent(const struct epoll_event& event) {
    int fd = event.data.fd;

    if (event.events & EPOLLIN) {
        if (isListenSocket(fd)) {
            ListenSocket* listen_socket = findListenSocket(fd);
            if (listen_socket) {
                handleNewConnection(listen_socket);
            }
        } else {
            handleClientData(fd);
        }
    }
    
    if (event.events & (EPOLLHUP | EPOLLERR)) {
        if (!isListenSocket(fd)) {
            disconnectClient(fd);
        }
    }
}

void VirtualServersManager::handleNewConnection(ListenSocket* listen_socket) {
    struct sockaddr_in client_addr;
    std::memset(&client_addr, 0, sizeof(client_addr));
    socklen_t client_len = sizeof(client_addr);
    
    int client_fd = accept(listen_socket->socket_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd < 0) {
        std::cerr << "Failed to accept connection" << std::endl;
        return;
    }
    _client_to_listen_socket[client_fd] = listen_socket; 
    
    Logger::getInstance().info("New client connected on FD: " + wss::i_to_dec(client_fd) + " to " + listen_socket->listen_config.host + ":" + wss::i_to_dec(listen_socket->listen_config.port));
    
    struct epoll_event event;
    event.events = EPOLLIN;
    event.data.fd = client_fd;
    
    if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, client_fd, &event) < 0) {
        close(client_fd);
        return;
    }
    
    _client_fds.push_back(client_fd);
}

void VirtualServersManager::handleClientData(int client_fd) {
    ClientState* client = ClientState::getOrCreateClientState(client_fd);

    try {
        switch (client->status) {
            case ClientState::READING_REQUEST:
                handleReadingRequest(client_fd, client);
                break;
            case ClientState::PROCESSING_REQUEST:
                handleProcessingRequest(client_fd, client);
                break;
            case ClientState::ERROR_HANDLING:
                handleErrorHandling(client_fd, client);
                break;
            case ClientState::WRITING_RESPONSE:
                handleWritingResponse(client_fd, client);
                break;
            case ClientState::WAITING_FILE:
                handleWaitingFile(client_fd, client);
                break;
            case ClientState::WAITING_CGI:
                handleWaitingCGI(client_fd, client);
                break;
            case ClientState::CLOSING:
                handleClosing(client_fd, client);
                break;
            case ClientState::CLOSED:
                handleClosed(client_fd, client);
                break;
        }
    
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "Exception processing client data: " << e.what();
        Logger::getInstance().error(oss.str());
        disconnectClient(client_fd);
    }
}

void VirtualServersManager::handleReadingRequest(int client_fd, ClientState* client) {
    Logger::getInstance().info("Reading request for client " + wss::i_to_dec(client_fd));

    try {   
        client->request_manager.process();
        
        if (client->hasError()) {
            Logger::getInstance().warning("Error parsing request: " + client->error.to_string());

            if (client->error_retry_count == 0) {
                client->original_request = client->request;
            }

            client->status = ClientState::ERROR_HANDLING;
            client->error_retry_count = 0;
            return;
        }
        
        if (client->isRequestComplete()) {
            Logger::getInstance().info("Request parsing complete for client " + wss::i_to_dec(client_fd));
            client->status = ClientState::PROCESSING_REQUEST;
            return;
        }
    } catch (const std::exception &e) {
        Logger::getInstance().error("Exception in handleReadingRequest: " + std::string(e.what()));
        client->error.set("Internal error during request reading", INTERNAL_SERVER_ERROR);
        client->status = ClientState::ERROR_HANDLING;
    }
}

void VirtualServersManager::handleProcessingRequest(int client_fd, ClientState* client) {
    Logger::getInstance().info("Processing request for client " + wss::i_to_dec(client_fd));

    try {
        std::map<int, ListenSocket*>::iterator map_it = _client_to_listen_socket.find(client_fd);
        if (map_it == _client_to_listen_socket.end()) {
            client->error.set("No listen socket found for client", INTERNAL_SERVER_ERROR);
            client->status = ClientState::ERROR_HANDLING;
            return;
        }

        ListenSocket* listen_socket = map_it->second;
        ServerConfig* server_config = findServerConfigForRequest(client->request, listen_socket);
        if (!server_config) {
            client->error.set("Virtual host not found", NOT_FOUND);
            client->status = ClientState::ERROR_HANDLING;
            return;
        }

        Location* location = server_config->findLocation(client->request.get_path());
        if (!location) {
            location = server_config->findLocation("/", false);
            if (!location) {
                client->error.set("No location configured", INTERNAL_SERVER_ERROR);
                client->status = ClientState::ERROR_HANDLING;
                return;
            }
        }

        if (!isMethodAllowed(server_config, location, client->request.method)) {
            client->error.set("Method not allowed", METHOD_NOT_ALLOWED);
            client->status = ClientState::ERROR_HANDLING;
            return;
        }

        client->response_manager.set_virtual_server(server_config);
        client->response_manager.set_location(location);

        if (isCgiRequest(location, client->request.get_path())) {
            Logger::getInstance().info("CGI request detected");
            client->status = ClientState::WAITING_CGI;
            return;
        }

        // Generar respuesta (puede ser normal o error)
        client->response_manager.generate_response();
        ResponseManager::RM_status rm_status = client->response_manager.get_status();

        // Pedir a ResponseManager fd activo si hay (lee o escribe un fichero)
        ActiveFileDescriptor afd = client->response_manager.get_active_file_descriptor();
        if (afd.fd != -1) {
            if (afd.fd == client_fd) {
                // Modificar socket existente del cliente
                struct epoll_event ev;
                ev.data.fd = afd.fd;
                ev.events = afd.mode;
                if (epoll_ctl(_epoll_fd, EPOLL_CTL_MOD, afd.fd, &ev) == -1) {
                    Logger::getInstance().error("epoll_ctl MOD failed for client fd: " + std::string(strerror(errno)));
                }
            } else {
                // Añadir nuevo file descriptor (archivo)
                struct epoll_event ev;
                ev.data.fd = afd.fd;
                ev.events = afd.mode;
                if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, afd.fd, &ev) == -1) {
                    Logger::getInstance().error("epoll_ctl ADD failed for file fd: " + std::string(strerror(errno)));
                }
            }
            client->status = ClientState::WAITING_FILE;
            return;
        }

        // Si llega aquí no hay fd activo, por tanto, toca escribir enel socket
        if (rm_status == ResponseManager::WRITING_RESPONSE) {
            Logger::getInstance().info("Registering client FD " + wss::i_to_dec(client_fd) + " for EPOLLOUT");
            struct epoll_event ev;
            ev.data.fd = client_fd;
            ev.events = EPOLLIN;
            if (epoll_ctl(_epoll_fd, EPOLL_CTL_MOD, client_fd, &ev) == -1) {
                Logger::getInstance().error("epoll_ctl MOD failed for client fd: " + std::string(strerror(errno)));
            }
            client->status = ClientState::WRITING_RESPONSE;
            return;
        }

        // Fallback: cierre por error
        Logger::getInstance().warning("Unexpected ResponseManager status after generate_response");
        client->status = ClientState::ERROR_HANDLING;

    } catch (std::exception &e) {
        std::ostringstream oss;
        oss << "Exception in handleProcessingRequest: " << std::string(e.what());
        Logger::getInstance().error(oss.str());
        client->error.set("Internal error during request processing", INTERNAL_SERVER_ERROR);
        client->status = ClientState::ERROR_HANDLING;
    }   
}

void VirtualServersManager::handleErrorHandling(int client_fd, ClientState* client) {
    Logger::getInstance().info("Handling error for client " + wss::i_to_dec(client_fd) + 
                              ": " + client->error.to_string());

    try {
        // No loops infinitos con la misma request
        if (client->error_retry_count >= MAX_ERROR_RETRIES) {
            Logger::getInstance().warning("Max error retries reached, sending default error page");
            client->response_manager.generate_response();
            client->status = ClientState::CLOSING;
            disconnectClient(client_fd);
            // QUESTION es necesario desconectar el fd? y si es keep alive? en HTTP1.1 se deja abierta o se cierra?
            return;
        }

        // Intentar reescribir la request para error page custom
        if (attemptErrorPageRewrite(client_fd, client)) {
            Logger::getInstance().info("Error page rewrite successful");
            client->status = ClientState::PROCESSING_REQUEST;
            client->error_retry_count++;
            return;
        }

        Logger::getInstance().info("No custom error page, switching to default error page");
        client->response_manager.generate_response();
        
        if (client->error.status() >= 400) {
            client->status = ClientState::CLOSING;
            disconnectClient(client_fd);
        } else {
            client->status = ClientState::WRITING_RESPONSE;
        }

    } catch (const std::exception& e) {
        Logger::getInstance().error("Exception in handleErrorHandling: " + std::string(e.what()));
        client->error.set("Critical error in error handling", INTERNAL_SERVER_ERROR);
        client->response_manager.generate_response();
        client->status = ClientState::CLOSING;
    }
}

void VirtualServersManager::handleWritingResponse(int client_fd, ClientState* client) {
    Logger::getInstance().info("Writing response for client " + wss::i_to_dec(client_fd));
    
    try {
        client->response_manager.process();
        
        if (client->response_manager.response_done()) {
            Logger::getInstance().info("Response sending complete for client " + wss::i_to_dec(client_fd));
            
            if (client->request.headers.close_status == RCS_CLOSE) {
                client->status = ClientState::CLOSING;
            } else {
                // Keep-alive: preparar para nueva request
                client->request_manager.new_request();
                client->response_manager.reset();
                client->error.set("", OK);
                client->error_retry_count = 0;
                
                // Restaurar EPOLLIN
                struct epoll_event ev;
                ev.data.fd = client_fd;
                ev.events = EPOLLIN;
                if (epoll_ctl(_epoll_fd, EPOLL_CTL_MOD, client_fd, &ev) == -1) {
                    Logger::getInstance().error("epoll_ctl MOD to EPOLLIN failed: " + std::string(strerror(errno)));
                }
                
                client->status = ClientState::READING_REQUEST;
            }
            return;
        }
        
        Logger::getInstance().info("Continue writing response");
        
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "Exception in handleWritingResponse: " << e.what();
        Logger::getInstance().error(oss.str());
        client->status = ClientState::CLOSING;
    }
}

void VirtualServersManager::handleWaitingFile(int client_fd, ClientState* client) {
    Logger::getInstance().info("Processing file I/O for client " + wss::i_to_dec(client_fd));
    
    try {
        ActiveFileDescriptor afd = client->response_manager.get_active_file_descriptor(); // QUESTION que es ActiveFileDescripto, contexto checkear
        
        if (afd.fd == -1) {
            Logger::getInstance().warning("No active file descriptor, switching to writing response");
            client->status = ClientState::WRITING_RESPONSE;
            return;
        }

        if (afd.fd == client_fd) {
            Logger::getInstance().info("Socket ready for writing response");
            client->response_manager.process();

            if (client->response_manager.response_done()) {
                Logger::getInstance().info("Response sending complete for cliente " + wss::i_to_dec(client_fd));

                if (client->request.headers.close_status == RCS_CLOSE) {
                    client->status = ClientState::CLOSING;
                } else {
                    // Keep-alice: preparar para nueva request
                    client->request_manager.new_request();
                    client->response_manager.reset();
                    client->error_retry_count = 0;

                    // Volver a epollin
                    struct epoll_event ev;
                    ev.data.fd = client_fd;
                    ev.events = EPOLLIN;
                    if (epoll_ctl(_epoll_fd, EPOLL_CTL_MOD, client_fd, &ev) == -1) {
                        Logger::getInstance().error("epoll_ctl MOD to EPOLLIN failed: "
                                                    + std::string(strerror(errno)));
                    }

                    client->status = ClientState::READING_REQUEST;
                }
            }
            return;
        }

        client->response_manager.process();
        
        if (client->response_manager.get_active_file_descriptor().fd == -1) {
            Logger::getInstance().info("File I/O done, preparing to send response");
            client->status = ClientState::WRITING_RESPONSE;
            return;
        }

        Logger::getInstance().info("Continue with writng/reading file");
        
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "Exception in handleWaitingFile: " << e.what();
        Logger::getInstance().error(oss.str());
        client->error.set("File I/O error", INTERNAL_SERVER_ERROR);
        client->status = ClientState::ERROR_HANDLING;
    }
}

void VirtualServersManager::handleWaitingCGI(int client_fd, ClientState* client) {  // QUESTION explicarlo todo
    Logger::getInstance().info("Handling CGI for client " + wss::i_to_dec(client_fd));
    
    try {
        static std::map<int, time_t> cgi_start_times;
        
        if (cgi_start_times.find(client_fd) == cgi_start_times.end()) {
            cgi_start_times[client_fd] = time(NULL);
            Logger::getInstance().info("Starting CGI execution...");
            return;
        }
        
        time_t elapsed = time(NULL) - cgi_start_times[client_fd];
        if (elapsed > 30) { // timeout de 30 segundos
            Logger::getInstance().warning("CGI timeout");
            cgi_start_times.erase(client_fd);
            client->error.set("CGI script timeout", INTERNAL_SERVER_ERROR);
            client->status = ClientState::ERROR_HANDLING;
            return;
        }
        
        if (elapsed >= 1) { // 1 o más segundos de procesamiento //QUESTION porque damos por completo cgi con 1 segundo de procesamiento
            Logger::getInstance().info("CGI execution complete");
            cgi_start_times.erase(client_fd);
            
            client->status = ClientState::WRITING_RESPONSE;
            return;
        }
        
        Logger::getInstance().info("Continue waiting for CGI");
        
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "Exception in handleWaitingCGI: " << e.what();
        Logger::getInstance().error(oss.str());
        client->error.set("CGI execution error", INTERNAL_SERVER_ERROR);
        client->status = ClientState::ERROR_HANDLING;
    }
} // ILYA como va el cgi-executor?

void VirtualServersManager::handleClosing(int client_fd, ClientState* client) {
    Logger::getInstance().info("Closing connection for client " + wss::i_to_dec(client_fd));
    
    try {
        if (client->response_manager.get_active_file_descriptor().fd != -1) {
            // TODO: Implementar cleanup en ResponseManager
            // KEVIN hay este meteodo de cleanup de ResponseManager?
            // QUESTION existe un cleanup para RequestManager? Donde se lo llama si existe?
        }
        
        std::string final_status = client->hasError() ? "ERROR: " + client->error.to_string() : "SUCCESS";
        Logger::getInstance().info("Client " + wss::i_to_dec(client_fd) + " session ended: " + final_status);
        
        client->status = ClientState::CLOSED;
        
    } catch (const std::exception& e) {
        std::ostringstream oss;
        oss << "Exception in handleClosing: " << e.what();
        Logger::getInstance().error(oss.str());
        client->status = ClientState::CLOSED;
    }
}

void VirtualServersManager::handleClosed(int client_fd, ClientState* client) {
    (void)client;
    Logger::getInstance().info("Client " + wss::i_to_dec(client_fd) + " is closed");
    disconnectClient(client_fd);
}


// ================ METHODS AUX DE ERROR ================

bool VirtualServersManager::attemptErrorPageRewrite(int client_fd, ClientState* client) { // QUESTION explicar
    std::map<int, ListenSocket*>::iterator map_it = _client_to_listen_socket.find(client_fd);
    if (map_it == _client_to_listen_socket.end()) {
        return false;
    }

    ListenSocket* listen_socket = map_it->second;
    ServerConfig* server_config = findServerConfigForRequest(client->request, listen_socket);
    Location* location = NULL;
    
    if (server_config) {
        location = server_config->findLocation(client->request.get_path());
    }

    // Buscar error page
    int status_code = static_cast<int>(client->error.status());
    std::string error_page_path;
    
    if (server_config) {
        // buscqueda jerarquizada loc > serv > def
        error_page_path = server_config->getErrorPage(status_code, location);
    }
    
    if (error_page_path.empty()) {
        return false; // No hay custom error page
    }

    // Backup original request
    if (client->error_retry_count == 0) {
        client->original_request = client->request;
    }
    
    // Crear nueva request GET para la error page
    client->request.reset();
    client->request.method = GET;
    client->request.protocol = "HTTP/1.1";
    client->request.uri.path = error_page_path;
    client->request.headers.host = client->original_request.headers.host;
    client->request.headers.port = client->original_request.headers.port;
    
    // Headers para debugging
    client->request.headers.put("X-Original-URI", client->original_request.uri.path);
    client->request.headers.put("X-Error-Status", status::stoa(client->error.status()));
    
    // Reset error
    client->error.set("", OK);
    
    Logger::getInstance().info("Request rewritten for error page: " + error_page_path);
    return true;
}

// ================ DISCONECT FD ================

void VirtualServersManager::disconnectClient(int client_fd) {
    Logger::getInstance().info("Disconnecting client FD: " + wss::i_to_dec(client_fd));
    
    _client_to_listen_socket.erase(client_fd);
    
    ClientState::cleanupClientState(client_fd);
    epoll_ctl(_epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);
    close(client_fd);
    
    std::vector<int>::iterator it = std::find(_client_fds.begin(), _client_fds.end(), client_fd);
    if (it != _client_fds.end()) {
        _client_fds.erase(it);
    }
}

// ================ REQUEST PROCESSING ================

void VirtualServersManager::processCompleteRequest(int client_fd, HTTPRequest& request) {
    Logger::getInstance().info("Processing complete request for FD: " + wss::i_to_dec(client_fd));
    Logger::getInstance().info("Host: " + request.get_host() + ", Path: " + request.get_path());
    
    // Encontrar el ListenSocket
    std::map<int, ListenSocket*>::iterator map_it = _client_to_listen_socket.find(client_fd);
    if (map_it == _client_to_listen_socket.end()) {
        std::cerr << "No listen socket found for client FD " << client_fd << std::endl;
        sendErrorResponse(client_fd, 500, "Internal Server Error");
        return;
    }

    ListenSocket* listen_socket = map_it->second;

    // Encontrar la configuración de servidor apropiada (virtual host)
    ServerConfig* server_config = findServerConfigForRequest(request, listen_socket);
    if (!server_config) {
        std::cerr << "No server config found for host " << request.get_host() << std::endl;
        sendErrorResponse(client_fd, 404, "Virtual host not found");
        return;
    }
    
    Logger::getInstance().info("Selected server config for host: " + request.get_host());
    
    // Encontrar la location apropiada
    Location* location = server_config->findLocation(request.get_path());
    if (!location) {
        std::cerr << "No location found for path " << request.get_path() << std::endl;
        sendErrorResponse(client_fd, 404, "Location not found");
        return;
    }
    
    // Verificar si el método está permitido
    if (!isMethodAllowed(server_config, location, request.method)) {
        std::cerr << "Method not allowed" << std::endl;
        sendErrorResponse(client_fd, 405, "Method not allowed");
        return;
    }
    
    // Procesar el request
    if (isCgiRequest(location, request.get_path())) {
        processCgiRequest(client_fd, request, location);
    } else {
        processStaticRequest(client_fd, server_config, location);
    }
}

ServerConfig* VirtualServersManager::findServerConfigForRequest(const HTTPRequest& request, ListenSocket* listen_socket) {
    std::string host = request.get_host();
    
    Logger::getInstance().info("Looking for server config for host: '" + host + "'");
    Logger::getInstance().info("Available virtual hosts: " + wss::i_to_dec(listen_socket->virtual_hosts.size()));
    
    // Buscar coincidencia exacta de server_name
    for (std::vector<ServerConfig*>::iterator it = listen_socket->virtual_hosts.begin(); 
         it != listen_socket->virtual_hosts.end(); ++it) {
        
        ServerConfig* config = *it;
        Logger::getInstance().info("Checking server config...");
        
        if (matchesServerName(config, host)) {
            Logger::getInstance().info("Found matching server config for host: " + host);
            return config;
        }
    }
    
    // Si no hay coincidencia, usar el primer servidor (default)
    Logger::getInstance().info("No exact match found, using default server config");
    return getDefaultServerConfig(listen_socket);
}

bool VirtualServersManager::matchesServerName(const ServerConfig* config, const std::string& host) const {
    return config->matchesServerName(host);
}

ServerConfig* VirtualServersManager::getDefaultServerConfig(ListenSocket* listen_socket) const {
    if (listen_socket->virtual_hosts.empty()) {
        return NULL;
    }
    return listen_socket->virtual_hosts[0];  // El primer servidor es el default
}

bool VirtualServersManager::isMethodAllowed(const ServerConfig* server_config, const Location* location, HTTPMethod method) {
    std::string method_str;
    switch (method) {
        case GET: method_str = "GET"; break;
        case POST: method_str = "POST"; break;
        case PUT: method_str = "PUT"; break;
        case DELETE: method_str = "DELETE"; break;
        default: return false;
    }
    
    // Verificar primero en la location
    if (location && !location->getMethods().empty()) {
        const std::vector<std::string>& location_methods = location->getMethods();
        for (std::vector<std::string>::const_iterator it = location_methods.begin(); 
             it != location_methods.end(); ++it) {
            if (*it == method_str) {
                return true;
            }
        }
        return false;
    }
    
    // Si no está definido en location, usar configuración del servidor
    return server_config->isMethodAllowed(method_str);
}

// ================ RESPONSE HANDLING ================

void VirtualServersManager::sendErrorResponse(int client_fd, int status_code, const std::string& message) {
    std::ostringstream response;
    response << "HTTP/1.1 " << status_code << " " << message << "\r\n"
             << "Content-Type: text/plain\r\n"
             << "Content-Length: " << message.length() << "\r\n"
             << "Connection: close\r\n"
             << "\r\n"
             << message;
    
    std::string response_str = response.str();
    send(client_fd, response_str.c_str(), response_str.length(), 0);
}

void VirtualServersManager::sendErrorResponse(int client_fd, const HTTPError& error) {
    int status_code = static_cast<int>(error.status());
    sendErrorResponse(client_fd, status_code, error.msg());
}

bool VirtualServersManager::isCgiRequest(const Location* location, const std::string& path) {
    if (!location) {
        return false;
    }

    std::string cgi_extension = location->getCgiExtension(); // QUESTION bien implementado?
    if (cgi_extension.empty()) {
        return false;
    }
    
    return path.size() >= cgi_extension.size() &&
           path.compare(path.size() - cgi_extension.size(), cgi_extension.size(), cgi_extension) == 0; // QUESTION como va compare?
}

void VirtualServersManager::processCgiRequest(int client_fd, HTTPRequest& request, const Location* location) { // ILYA implementar aqui
    (void)request;
    (void)location;
    
    std::string response = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 27\r\n"
        "Connection: close\r\n"
        "\r\n"
        "CGI processing placeholder";
    
    send(client_fd, response.c_str(), response.length(), 0);
}

void VirtualServersManager::processStaticRequest(int client_fd, const ServerConfig* server_config, const Location* location) {
    (void)server_config;
    (void)location;
    
    std::string response = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html\r\n"
        "Content-Length: 45\r\n"
        "Connection: close\r\n"
        "\r\n"
        "<html><body><h1>Hello World!</h1></body></html>";
    
    send(client_fd, response.c_str(), response.length(), 0);
}

// ================ MAIN RUN METHOD ================

void VirtualServersManager::run() {
    Logger::getInstance().info(std::string(10, '=') + " Starting WEBSERVER " + std::string(10, '='));
    // Use DebugView boxed format
    {
        std::vector<std::string> lines;
        for (std::map<Listen, std::vector<ServerConfig*> >::const_iterator it = _virtual_hosts.begin();
             it != _virtual_hosts.end(); ++it) {
            lines.push_back("listen " + it->first.host + ":" + wss::i_to_dec(it->first.port) + " | vhosts: " + wss::i_to_dec(it->second.size()));
            for (size_t i = 0; i < it->second.size(); ++i) {
                const ServerConfig* cfg = it->second[i];
                std::string tag = (i == 0) ? " [DEFAULT]" : "";
                lines.push_back("  - " + wss::i_to_dec(i + 1) + tag + " names: " + cfg->getServerNamesString());
                lines.push_back("     root: " + cfg->getRoot() + " | locations: " + wss::i_to_dec(cfg->locations.size()));
            }
        }
        DebugView::printBox("VIRTUAL HOSTS", lines);
    }
    
    try {
        setupEpoll();
    } catch (const std::exception& e) {
        std::cerr << "Setup failed: " << e.what() << std::endl;
        return;
    }
    
    Logger::getInstance().info(std::string(10, '=') + " Starting EVENT LOOP " + std::string(10, '='));
    
    while (true) {
        int incoming = epoll_wait(_epoll_fd, _events.data(), _events.size(), -1);
        
        if (incoming < 0) {
            std::cerr << "epoll_wait failed: " << strerror(errno) << std::endl;
            break;
        }
        
        for (int i = 0; i < incoming; ++i) {
            try {
                handleEvent(_events[i]);
            } catch (const std::exception& e) {
                std::cerr << "Error handling event: " << e.what() << std::endl;
            }
        }
    }
    
    Logger::getInstance().info(std::string(10, '=') + " Closing EVENT LOOP " + std::string(10, '='));
}

// ================ DEBUG METHODS ================

void VirtualServersManager::printVirtualHostsInfo() const {
    std::vector<std::string> lines;
    for (std::map<Listen, std::vector<ServerConfig*> >::const_iterator it = _virtual_hosts.begin();
         it != _virtual_hosts.end(); ++it) {
        lines.push_back("listen " + it->first.host + ":" + wss::i_to_dec(it->first.port) + " | vhosts: " + wss::i_to_dec(it->second.size()));
        for (size_t i = 0; i < it->second.size(); ++i) {
            const ServerConfig* cfg = it->second[i];
            std::string tag = (i == 0) ? " [DEFAULT]" : "";
            lines.push_back("  - " + wss::i_to_dec(i + 1) + tag + " names: " + cfg->getServerNamesString());
            lines.push_back("     root: " + cfg->getRoot() + " | locations: " + wss::i_to_dec(cfg->locations.size()));
        }
    }
    DebugView::printBox("VIRTUAL HOSTS", lines);
}

void VirtualServersManager::printListenSocketsInfo() const {
    std::cout << "\n📊 Listen Sockets Information:" << std::endl;
    
    for (std::map<Listen, ListenSocket>::const_iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        
        std::cout << "  🔌 " << it->first.host << ":" << it->first.port 
                  << " (FD: " << it->second.socket_fd << ")" 
                  << " - " << it->second.virtual_hosts.size() << " virtual hosts" << std::endl;
    }
}
=== ./src/ServerValidator.cpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerValidator.cpp                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/30 12:44:48 by irozhkov          #+#    #+#             */
/*   Updated: 2025/06/04 20:13:29 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ServerValidator.hpp"

// Temporary color macros to fix compilation
#define RED        "\033[1;91m"
#define GREEN      "\033[1;92m"
#define YELLOW     "\033[1;93m"
#define BLUE       "\033[1;94m"
#define RESET      "\033[0m"

void ServerValidator::validate(const std::vector<ParsedServer>& servers)
{
	std::map<ListenKey, std::vector<const ParsedServer*> > listen_map;
	std::map<std::string, std::set<ListenKey> > name_to_hostports;

	for (size_t s = 0; s < servers.size(); ++s)
	{
		const ParsedServer& server = servers[s];
		for (size_t l = 0; l < server.listens.size(); ++l)
		{
			const Listen& ld = server.listens[l];
			ListenKey key;
			key.host = ld.host;
			key.port = ld.port;

			listen_map[key].push_back(&server);

			for (size_t n = 0; n < server.server_names.size(); ++n)
			{
				name_to_hostports[server.server_names[n]].insert(key);
			}
		}
	}

	std::map<ListenKey, std::vector<const ParsedServer*> >::iterator it1 = listen_map.begin();
	while (it1 != listen_map.end())
	{
		const ListenKey& key = it1->first;
		const std::vector<const ParsedServer*>& servers_list = it1->second;

		if (servers_list.size() > 1)
		{
			std::cout << YELLOW << "WARNING: " << RESET << "Multiple servers on " << YELLOW <<
			key.host << ":" << key.port << RESET << ". According to the subject requirements, " <<
			"if two or more servers are configured with the same host:port, " << YELLOW <<
			"the first one in order is considered the primary" << RESET << "." << std::endl;
		}
		++it1;
	}

	std::map<std::string, std::set<ListenKey> >::iterator it2 = name_to_hostports.begin();
	while (it2 != name_to_hostports.end())
	{
		if (it2->second.size() > 1)
		{
			std::cout << YELLOW << "WARNING: " << RESET << "Server name " <<  YELLOW << 
			it2->first << RESET << " used on multiple host:port combinations. " <<
 			"According to the subject requirements, if two or more servers are " << 
			"configured with the same host:port, " << YELLOW <<
			"the first one in order is considered the primary" << RESET << "." << std::endl;
		}
		++it2;
	}
}


=== ./src/buffer/SysBufferFactory.cpp ===

#include "SysBufferFactory.hpp"

SysBuffer *  SysBufferFactory::get_buffer(sys_buffer_type type, int fd)
{
    switch (type)
    {
        case SYSBUFF_FILE: return new SysFileBuffer(fd);
        case SYSBUFF_SOCKET: return new SysNetBuffer(fd);
        default: throw new std::runtime_error("Code error: unknown SysBuffer type");
    }
}
=== ./src/buffer/HTTPRequestBuffer.cpp ===
#include "HTTPRequestBuffer.hpp"

HTTPRequestBuffer::HTTPRequestBuffer(){_offset = 0;}

HTTPRequestBuffer::~HTTPRequestBuffer(){}

void HTTPRequestBuffer::new_request() {discard_current(); _offset = 0; _last_read_size = 0;}

bool HTTPRequestBuffer::get_crlf_line(uint8_t * & _begin, uint8_t * & _end)
{
    uint8_t * start = itbegin();
    uint8_t * ptr = start + _offset;

    for (; ptr != itend(); ++ptr) 
    {
        if (*ptr == '\n') 
        {
            if (ptr != start && *(ptr - 1) == '\r')
            {
                _begin = start;
                _end = ptr - 1;
            }
            else
            {
                _begin = start;
                _end = ptr;
            }
            _last_read_size = ptr - itbegin();       
            _offset = 0;
            consume_bytes(ptr - start + 1);
            return true;
        }
    };
    _offset = ptr - itbegin();
    _last_read_size = _offset;
    return false; 
}

bool HTTPRequestBuffer::get_chunk(ssize_t chunk_size, uint8_t * & _begin, uint8_t * & _end)
{
    if (size() < chunk_size)
    {
        _last_read_size = size();
        return false;
    }
    _begin = itbegin();
    _end = itbegin() + chunk_size;
    consume_bytes(chunk_size);
    _last_read_size = chunk_size;
    return true;
}

bool HTTPRequestBuffer::get_crlf_line(std::string::iterator & _begin, std::string::iterator & _end)
{
    std::string::iterator start = begin();
    std::string::iterator ptr = start + _offset;

    for (; ptr != end(); ++ptr) 
    {
        if (*ptr == '\n') 
        {
            if (ptr != start && *(ptr - 1) == '\r')
            {
                _begin = start;
                _end = ptr - 1;
            }
            else
            {
                _begin = start;
                _end = ptr;
            }
            _last_read_size = ptr - begin();       
            _offset = 0;
            consume_bytes(ptr - start + 1);
            return true;
        }
    };
    _offset = ptr - begin();
    _last_read_size = _offset;
    return false; 
}

bool HTTPRequestBuffer::get_chunk(ssize_t chunk_size, std::string::iterator & _begin, std::string::iterator & _end)
{
    if (size() < chunk_size)
    {
        _last_read_size = size();
        return false;
    }
    _begin = begin();
    _end = begin() + chunk_size;
    consume_bytes(chunk_size);
    _last_read_size = chunk_size;
    return true;
}


ssize_t HTTPRequestBuffer::previous_read_size() const {return _last_read_size;}

=== ./src/buffer/SysNetBuffer.cpp ===
#include "SysNetBuffer.hpp"

SysNetBuffer::SysNetBuffer(int socket_fd):SysBuffer(socket_fd){}

ssize_t SysNetBuffer::write(uint8_t *buff, size_t size)
{
    return send(_fd, buff, size, 0);
}

ssize_t SysNetBuffer::read(uint8_t *buff, size_t size)
{
    return recv(_fd, buff, size, 0);
}
=== ./src/buffer/SysBuffer.cpp ===
#include "SysBuffer.hpp"
=== ./src/buffer/SysFileBuffer.cpp ===
#include "SysFileBuffer.hpp"

SysFileBuffer::SysFileBuffer(int fd)
:SysBuffer(fd){}

ssize_t SysFileBuffer::write(uint8_t *buff, size_t size)
{
    return ::write(_fd, buff, size);
}

ssize_t SysFileBuffer::read(uint8_t *buff, size_t size)
{
    return ::read(_fd, buff, size);
}
=== ./src/buffer/HTTPResponseBuffer.cpp ===
#include "HTTPResponseBuffer.hpp"

void HTTPResponseBuffer::put_protocol(std::string const & protocol) 
{
    append(protocol);
    append(" ");
}

void HTTPResponseBuffer::put_status(HTTPError const & err)
{
    append(status::stoa(err.status()));
    append(" ");
    append(err.msg());
    append("\r\n");
}

void HTTPResponseBuffer::put_header(std::string const & name, std::string const & value)
{
    append(name);
    append(": ");
    append(value);
    append("\r\n");
}

void HTTPResponseBuffer::put_header_time(std::string const & name, time_t time)
{
    char buffer[100];
    struct tm* gmtimeinfo = gmtime(&time); 
    strftime(buffer, sizeof(buffer), "%a, %d %b %Y %H:%M:%S GMT", gmtimeinfo);
    put_header(name, buffer);
}

void HTTPResponseBuffer::put_header_number(std::string const & name, size_t n)
{
    std::stringstream ss;
    ss << n;
    put_header(name, ss.str());
}

void HTTPResponseBuffer::put_body(std::string const & body)
{
    append(body);
}

void HTTPResponseBuffer::put_body_chunk(std::string const & chunk)
{
    append(wss::i_to_hex(chunk.size()));
    append("\r\n");
    append(chunk);
}

/*
    Reserves enough bytes to write from fd to buffer.
    Then, reads the fd into the buffer and returns the result.
*/
ssize_t HTTPResponseBuffer::write_from_fd(int fd, size_t n)
{
    reserve(size() + n);

    ssize_t rb = read(fd, itend(), n);
    if (rb > 0)
        manual_increase(rb);
    return rb;
}

void HTTPResponseBuffer::put_new_line(){append("\r\n");}

=== ./src/buffer/ReadNetBuffer.cpp ===
#include <iostream>
#include "ReadNetBuffer.hpp"
#include <cassert>

const size_t ReadNetBuffer::START_BUFFER_SIZE = 1000;
const size_t ReadNetBuffer::SHRINK_BUFFER_SIZE = 1001;

ReadNetBuffer::ReadNetBuffer()
{
    _buffer = new uint8_t[START_BUFFER_SIZE];
    _start = _buffer;
    _tail = _buffer;
    _end = _buffer + START_BUFFER_SIZE;
}

ReadNetBuffer::~ReadNetBuffer(){delete [] _buffer;}

void ReadNetBuffer::discard_current()
{
    if (static_cast<size_t>(capacity()) >= SHRINK_BUFFER_SIZE)
        shrink();
}

void ReadNetBuffer::reserve(ssize_t n)
{
    if (this->capacity() >= n)
        return ;
    
    size_t size = this->size();

    uint8_t * new_buffer = new uint8_t[n];
    std::memcpy(new_buffer, _start, size);
    delete [] _buffer;
    _buffer = new_buffer;
    _start = new_buffer;
    _tail = _start + size;
    _end = new_buffer + n;
}

/*
    Kinda dangerous. Use after reserve or knowing there's space.
*/
void ReadNetBuffer::manual_increase(size_t n)
{
    _tail += n;
}

void ReadNetBuffer::shrink()
{
    size_t size = this->size();
    size_t new_capacity = std::max<size_t>(START_BUFFER_SIZE, size);

    uint8_t * new_buffer = new uint8_t[new_capacity];
    memcpy(new_buffer, _start, size);
    delete [] _buffer;

    _buffer = new_buffer;
    _start = new_buffer;
    _tail = _start + size;
    _end = new_buffer + new_capacity;
}

void ReadNetBuffer::append(uint8_t const * str, ssize_t size)
{
    if (_tail - _buffer + size > capacity())
        expand(_tail - _buffer + size);
    std::memcpy(_tail, str, size);
    _tail += size;
}

void ReadNetBuffer::append(std::string const & str)
{
    if ((ssize_t) (_tail - _buffer + str.size()) > capacity())
        expand(_tail - _buffer + str.size());
    std::memcpy(_tail, str.c_str(), str.size());
    _tail += str.size();
}


void ReadNetBuffer::expand(size_t min_size)
{
    size_t new_capacity = std::max<size_t>(std::max<size_t>(capacity() * 1.7, START_BUFFER_SIZE), min_size);
    size_t size = this->size();

    uint8_t * new_buffer = new uint8_t[new_capacity];
    std::memcpy(new_buffer, _start, size);
    delete [] _buffer;

    _buffer = new_buffer;
    _start = new_buffer;
    _tail = _start + size;
    _end = new_buffer + new_capacity;
}

void ReadNetBuffer::clear()
{
    delete [] _buffer;
    _buffer = new uint8_t[START_BUFFER_SIZE];
    _start = _buffer;
    _tail = _buffer;
    _end = _buffer + START_BUFFER_SIZE;
}

void ReadNetBuffer::consume_bytes(ssize_t bytes)
{
    _start += bytes;
}


uint8_t * ReadNetBuffer::get_start(){return _start;}

ssize_t ReadNetBuffer::capacity() const {return _end - _buffer;}

ssize_t ReadNetBuffer::size() const {return _tail - _start;}

uint8_t * ReadNetBuffer::itbegin(){return  _start;}

uint8_t *  ReadNetBuffer::itend(){return  _tail;}

uint8_t const *  ReadNetBuffer::citbegin() const {return  _start;}

uint8_t const *  ReadNetBuffer::citend() const{return  _tail;}

std::string::iterator ReadNetBuffer::begin(){return std::string::iterator((char *) _start);}

std::string::iterator ReadNetBuffer::end(){return std::string::iterator((char *) _tail);}

std::string::const_iterator ReadNetBuffer::cbegin() const {return std::string::const_iterator((char *) _start);}

std::string::const_iterator ReadNetBuffer::cend() const{return std::string::const_iterator((char *) _tail);}

=== ./inc/RequestValidator.hpp ===
#pragma once

#include <string>
#include "MediaType.hpp"
#include "Status.hpp"
#include "URI.hpp"
#include "HTTPRequest.hpp"
#include "HTTPError.hpp"

class RequestValidator 
{
public:
    RequestValidator(HTTPRequest & request, HTTPError & error); // And config

    void validate_method(HTTPMethod const & method);
    void validate_uri(URI const & uri);
    void validate_headers(HTTPRequest const & request, FieldSection const & hdr);
    void validate_body(HTTPBody const & body);
    void validate_protocol(std::string const & protocol);
    void validate_request(HTTPRequest const & request);
    void validate_first_line(HTTPRequest const & request);
    void validate_extensions(std::string const & filename, std::vector<std::string> const & extensions);
    bool validate_extension(std::string const & filename, std::string const & extension);

    HTTPError const * error();

private:
    HTTPRequest & _request;
    HTTPError & _error;

    void put_error(std::string const & text, Status status);
};
=== ./inc/FieldSection.hpp ===
#pragma once

#include <string>
#include <vector>
#include <iostream>
#include <sstream>
#include <map>
#include "HTTPElement.hpp"
#include "MediaType.hpp"

struct Coding 
{
    std::string name;
    std::vector<std::pair<std::string, std::string> > parameters;
};

enum e_close_status {RCS_CLOSE, RCS_KEEP_ALIVE};

struct FieldSection : public HTTPElement
{
    std::map<std::string, std::string > fields;

    std::string host;
    int port;
    int content_length;
    std::vector<Coding> transfer_encodings;
    std::vector<std::string> connections;
    std::vector<std::string> expectations;
    MediaType content_type;
    std::map<std::string, std::string> cookies;
    
    // Other data
    e_close_status close_status;

    FieldSection();
    void reset();
    void print(std::ostream & os) const;
    void put(std::string const & name, std::string const & value);
    void put_cookie(std::string::iterator name_start, std::string::iterator name_end, std::string::iterator value_start, std::string::iterator value_end);
};

std::ostream & operator<<(std::ostream & os,  FieldSection const & media);
=== ./inc/SysNetBuffer.hpp ===
#pragma once

#include "SysBuffer.hpp"
#include <sys/socket.h>

class SysNetBuffer : public SysBuffer 
{
public:
    SysNetBuffer(int socket_fd);
    ssize_t write(uint8_t *buff, size_t size);
    ssize_t read(uint8_t *buff, size_t size);

private:
};



=== ./inc/Listen.hpp ===
#ifndef LISTEN_HPP
#define LISTEN_HPP

#include <string>
#include <iostream>

struct Listen {
    std::string host;
    int         port;
    bool        is_default;

    typedef Listen VirtualServerKey;

    Listen(const std::string& host = "0.0.0.0", const int port = 8080, bool is_default = false);
    ~Listen();
    
    bool operator==(const Listen& other) const;
    bool operator<(const Listen& other) const;

    std::string to_string() const;
};


std::ostream& operator<<(std::ostream& os, const Listen& pl);

#endif
=== ./inc/ElementParser.hpp ===
#pragma once

#include <string>
#include "HTTPRequest.hpp"
#include "FieldSection.hpp"
#include "ParsingUtil.hpp"
#include "StringUtil.hpp"

class HTTPError;

class ElementParser {
public:
    ElementParser(HTTPError & _error);

    void parse_method(std::string::iterator & begin, std::string::iterator & end, HTTPMethod & method);
    void parse_protocol(std::string::iterator & begin, std::string::iterator & end, std::string & protocol);
    void parse_path(std::string::iterator & begin, std::string::iterator & end, std::string & path);
    void parse_host(std::string::iterator & begin, std::string::iterator & end, std::string & host);
    void parse_port(std::string::iterator & begin, std::string::iterator & end, int & port);
    void parse_schema(std::string::iterator & begin, std::string::iterator & end, std::string & schema);
    void parse_fragment(std::string::iterator & begin, std::string::iterator & end, std::string & query);
    void parse_query(std::string::iterator & begin, std::string::iterator & end, std::string & fragment);
    void parse_field_value(std::string::iterator & begin, std::string::iterator & end, std::string & value);
    void parse_field_token(std::string::iterator & begin, std::string::iterator & end, std::string & name);
   
    void parse_content_length_field(std::string::iterator & begin, std::string::iterator & end, int & length);
    void parse_comma_separated_values(std::string::iterator & begin, std::string::iterator & end, std::vector<Coding> & values);
    void parse_dquote_string(std::string::iterator & begin, std::string::iterator & end, std::string & str);

private:
    HTTPError & _error;

    void normalize_path(std::string & str);
    void percentage_decode(std::string & str);
    void replace_percentage(std::string::iterator & it, std::string & str);
};
=== ./inc/RequestManager.hpp ===
#pragma once

#include <stdexcept>
#include "HTTPRequest.hpp"
#include "RequestValidator.hpp"
#include "ElementParser.hpp"
#include "RequestParser.hpp"
#include "SysBufferFactory.hpp"
#include "SysBuffer.hpp"
#include "SysFileBuffer.hpp"
#include "SysNetBuffer.hpp"

class RequestManager 
{
public:
    RequestManager(HTTPRequest & request, HTTPError & error, SysBufferFactory::sys_buffer_type type, int fd);
    ~RequestManager();

    void process();
    bool request_done() const;
    void new_request();
    HTTPError & gerError();

private:
    static const size_t _READ_BUFFER_SIZE = 2000;

    HTTPRequest & _request;
    HTTPError & _error;
    RequestValidator _validator;
    ElementParser _element_parser;
    RequestParser _request_parser;
    SysBuffer * _sys_buffer;
    uint8_t _read_buffer[_READ_BUFFER_SIZE];
};
=== ./inc/File.hpp ===
#pragma once

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <iostream>
#include <sstream>
#include <string>
#include <ctime>
#include "Logger.hpp"
#include "Utils.hpp"

/*
    This class is a persistent member of other classes meant to manage multiple instances 
    of opening and requesting file information, 
    hiding linux implementation details to provide a more comfortable interface.
    And providing a weak form of RAII.
*/

class File 
{
public:
    enum filetype {NONE, REGULAR, DIRECTORY};
    enum descriptor_status {OK, NOTFOUND, NOPERM, BADFILENAME, RAREFILE, ERROR};

    File(std::string const & path, int mode);
    File();
    ~File();

    void open(std::string const & path, int mode, int f = 0);
    void close();

    off_t size() const;
    time_t last_modified() const;
    descriptor_status get_status() const;

    struct dirent * dir_next();

    int fd;
    enum filetype filetype;

private:
    struct stat _statbuf;
    DIR * _dir;

    void handle_error();
    void destroy_current();
    void open_file(std::string const & src, int mode, int f = 0);
    enum descriptor_status status;

    File(File const &);
    File & operator=(File const &);
};

=== ./inc/ParsingUtil.hpp ===
#pragma once

#include <string>
#include <stdexcept>

namespace parse 
{
    bool is_digit(char c);
    bool is_alpha(char c);
    bool is_vchar(char c);
    bool is_delimiter(char c);
    bool is_token_char(char c);
    bool is_token(std::string const &);
    bool is_whitespace(char c);
    bool is_uri_char(char c);
    bool is_unreserved(char c);
    bool is_sub_delim(char c);
    bool is_pchar(char c);
    bool is_protocol_char(char c);
    bool is_host_char(char c);
    bool is_fragment_char(char c);
    bool is_query_char(char c);
    bool is_ascii_whitespace(char c);
    bool is_hexa_char(char c);
    bool is_field_value_char(char c);
    bool is_qdtext_char(char c);
    bool is_quoted_pair_char(char c);
    bool is_obs_text_char(char c);
    bool is_cookie_char(char c);
    char byte_char_to_hex(int c);

    void first_line_sanitize(std::string::iterator begin, std::string::iterator end);
    void sanitize_header_value(std::string::iterator start, std::string::iterator end);

    char hex_to_byte(char c);

    size_t s_to_hex(std::string::iterator start, std::string::iterator end, size_t max);
}
=== ./inc/SysFileBuffer.hpp ===
#pragma once

#include "SysBuffer.hpp"
#include <unistd.h>

class SysFileBuffer : public SysBuffer 
{
public:
    SysFileBuffer(int fd);
    ssize_t write(uint8_t *buff, size_t size);
    ssize_t read(uint8_t *buff, size_t size);

private:
};

=== ./inc/HTTPResponseBuffer.hpp ===
#pragma once

#include <cstdlib>
#include <sstream>
#include <ctime>
#include <unistd.h>
#include "StringUtil.hpp"
#include "HTTPMethod.hpp"
#include "ReadNetBuffer.hpp"
#include "HTTPError.hpp"

class HTTPResponseBuffer : public ReadNetBuffer
{
public:
    void put_protocol(std::string const & protocol);
    void put_status(HTTPError const & err);
    void put_header(std::string const & name, std::string const & value);
    void put_header_time(std::string const & name, time_t time);
    void put_header_number(std::string const & name, size_t n);
    void put_body(std::string const & body);
    void put_body_chunk(std::string const & body);
    void put_new_line();
    
    ssize_t write_from_fd(int fd, size_t n);
};
=== ./inc/Enums.hpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Enums.hpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/16 18:24:40 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 18:25:55 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ENUMS_HPP
# define ENUMS_HPP

enum AutoIndexState {
    AINDX_DEF_OFF,
    AINDX_DEF_ON,

    AINDX_SERV_OFF,
    AINDX_SERV_ON,

    AINDX_LOC_OFF,
    AINDX_LOC_ON
};

#endif

=== ./inc/HTTPRequest.hpp ===
#pragma once

#include <vector>
#include <sstream>
#include "HTTPElement.hpp"
#include "FieldSection.hpp"
#include "HTTPBody.hpp"
#include "Logger.hpp"

struct HTTPRequest : public HTTPElement
{
    // Request componentes
    URI uri;
    std::string protocol;
    HTTPMethod method;
    FieldSection headers; 
    HTTPBody body;
    
    HTTPRequest();
    std::string to_string();
    void reset();
    void print(std::ostream & os) const;

    int get_port() const;
    std::string const get_host() const;
    std::string const get_path() const;
};

std::ostream & operator<<(std::ostream & os, const HTTPRequest &request);

=== ./inc/Parsed.hpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Parsed.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/30 13:51:01 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 18:30:04 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef WEBSERV_PARSED_HPP
#define WEBSERV_PARSED_HPP

#include <fstream>
#include <iostream>
#include <map>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include "Enums.hpp"
#include "Listen.hpp"
#include "Location.hpp"

class ServersManager;

struct ParsedServer {
	std::vector<Listen> listens;
	std::vector<std::string> server_names;
	std::string root;
	std::vector<std::string> index_files;
	std::map<int, std::string> error_pages;
	std::vector<std::string> allow_methods;
	AutoIndexState autoindex;
//	bool autoindex;
	std::string client_max_body_size;
	std::map<std::string, Location> locations;

	ParsedServer()
		: autoindex(AINDX_DEF_OFF) {}

	ParsedServer(const Listen& listen,
				 const std::vector<std::string>& server_names,
				 const std::string& root,
				 const std::vector<std::string>& index_files,
				 const std::map<int, std::string>& error_pages,
				 const std::vector<std::string>& allow_methods,
				 const std::map<std::string, Location>& locations);

	~ParsedServer();
};

typedef std::vector<ParsedServer> ParsedServers;

// PARSING

std::vector<std::string> tokenize(const std::string& content);

size_t expect(const std::vector<std::string>& tokens, size_t i, const std::string& expected);

int to_int(const std::string& s);

Listen parse_listen(const std::vector<std::string>& tokens);

Location parseLocation(const std::vector<std::string>& tokens, size_t& i);

ParsedServer parseServer(const std::vector<std::string>& tokens, size_t& i);

std::vector<ParsedServer> parseConfig(const std::vector<std::string>& tokens);

// PROCESS
int parseProcess(int argc, char **argv, ParsedServers& parsedConfig);

#endif // WEBSERV_PARSED_HPP

=== ./inc/HTTPError.hpp ===
#pragma once

#include <string>
#include "Logger.hpp"
#include "Status.hpp"


class HTTPError 
{
public:
    HTTPError();
    HTTPError(std::string const & motive, Status _status);

    void log() const;
    Status status() const;
    std::string const & msg() const;

    void set(std::string const & motive, Status _status);
    std::string const to_string() const;

private:
    std::string _motive;
    Status _status;
};
=== ./inc/Status.hpp ===
#pragma once

#include <string>
#include <stdexcept>

enum Status {
    NO_STATUS = 0,
    OK = 200,
    BAD_REQUEST = 400,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    METHOD_NOT_ALLOWED = 405,
    CONTENT_TOO_LARGE = 413,
    URI_TOO_LONG = 414,
    UNSUPPORTED_MEDIA_TYPE = 415,
    EXPECTATION_FAILED = 417,
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
    INTERNAL_SERVER_ERROR = 500,
    NOT_IMPLEMENTED = 501,
    VERSION_NOT_SUPPORTED = 505,
};

enum StatusType {
    STYPE_IMMEDIATE_RESPONSE,
    STYPE_GENERATE_RESPONSE
};

namespace status {
    std::string const & status_to_text(Status const & status);
    std::string const & stoa(Status const & status);
    StatusType status_type(Status const & status);
}


=== ./inc/HTTPElement.hpp ===
#pragma once

#include <iostream>

class HTTPElement 
{
public:
    virtual ~HTTPElement(){};
    virtual void print(std::ostream & os) const = 0;
    virtual void reset() = 0;
    //virtual void validate() = 0;

    // setConfig()
    
    // OR

    // virtual void validate(config *)
};
=== ./inc/HTTPMethod.hpp ===
#pragma once

#include <iostream>
#include "StringUtil.hpp"
#include "Utils.hpp"

enum HTTPMethod 
{
    NOMETHOD, GET, POST, DELETE, PUT
};

std::ostream & operator<<(std::ostream & os, HTTPMethod method);

namespace method {
    HTTPMethod str_to_method(std::string const & str);
    std::string const method_to_str(HTTPMethod const & m);
};
=== ./inc/URI.hpp ===
#pragma once

#include <string>
#include <iostream>
#include "HTTPElement.hpp"

struct URI : public HTTPElement
{
    std::string host;
    std::string path;
    std::string query;
    std::string fragment;
    std::string schema;
    int port;
    
    size_t length;

    URI();
    void reset();
    void print(std::ostream & os) const;
};

std::ostream & operator<<(std::ostream & os, URI const & uri);
=== ./inc/RequestParser.hpp ===
#pragma once

#include <string>
#include <iostream>
#include <stdint.h>
#include <stdexcept>
#include <sstream>
#include <stdlib.h>
#include "Logger.hpp"
#include "HTTPRequest.hpp"
#include "HTTPRequestBuffer.hpp"
#include "RequestValidator.hpp"
#include "StringUtil.hpp"
#include "ParsingUtil.hpp"
#include "HTTPError.hpp"
#include "ElementParser.hpp"

// struct headerType {
//     char *name;
//     bool singleton;
//     void (RequestParser::*parser_f)(std::string const & value);
// };


class RequestParser 
{
public:
    enum parsing_status {PRS_FIRST_LINE, PRS_HEADER_LINE, PRS_BODY, PRS_CHUNKED_SIZE, PRS_CHUNKED_BODY, PRS_TRAILER_LINE, PRS_DONE};

    static const size_t URI_MAX_LENGTH;
    static const size_t FIRST_LINE_MAX_LENGTH;
    static const size_t HEADER_LINE_MAX_LENGTH;
    static const size_t MAX_CONTENT_LENGTH;
    static const size_t MAX_HEADER_FIELDS;
    static const size_t MAX_TRAILER_FIELDS;
    static const size_t MAX_CHUNK_SIZE;
    static const size_t CHUNKED_SIZE_LINE_MAX_LENGTH;

    RequestParser(HTTPRequest & request, HTTPError & _error, ElementParser & _element_parser);

    // Request managment
    void append(uint8_t const * str, ssize_t size);
    void new_request();
    parsing_status get_status() const;
    
    // Parsing functions
    void parse_first_line();
    void parse_header_line();
    void parse_body();
    void parse_chunked_size();
    void parse_chunked_body();

    bool test_first_line();
    bool test_chunk_size();
    bool test_chunk_body();
    bool test_body();
    bool test_trailer_line();
    bool test_header_line();
    
    void process_headers();

    // Debug
    void dump_remainder() const;
    std::string const get_remainder() const;

private:
    struct wsHeaders {
        std::string name;
        void (RequestParser::*parser_f)(std::string & value);
    };

    static const wsHeaders headers[];

    HTTPRequestBuffer _buffer;

    HTTPRequest & _request;
    HTTPError & _error;
    ElementParser &  _element_parser;

    parsing_status _status;
    int _empty_skip_count;
    bool _processing;
    size_t _header_field_count;
    size_t _trailer_field_count;
    size_t _chunk_length;

    std::string::iterator _begin, _end;

    void percentage_decode(std::string & str);

    void normalize_path(std::string & str);
    void replace_percentage(std::string::iterator & it, std::string & str);

    void get_path(std::string::iterator & token_begin, std::string::iterator & token_end);
    void get_hier_part(std::string::iterator & token_begin, std::string::iterator & token_end); 
    void get_query(std::string::iterator & token_begin, std::string::iterator & token_end);
    void get_fragment(std::string::iterator & token_begin, std::string::iterator & token_end);
    void get_schema(std::string::iterator & token_begin, std::string::iterator & token_end);
    bool has_authority(std::string::iterator & token_begin, std::string::iterator & token_end) const;

    void parse_method();
    void parse_uri();
    void parse_protocol();
    void parse_host_field(std::string & value);
    void parse_content_length_field(std::string & value);
    void parse_transfer_encoding_field(std::string & value);
    void parse_connection_field(std::string & value);
    void parse_expect_field(std::string & value);
    void parse_content_type_field(std::string & value);
    void parse_cookie_field(std::string & value);
    void parse_parameters(std::string::iterator begin, std::string::iterator end, std::vector<std::pair<std::string, std::string> > & parameters);

    std::string::iterator parse_transfer_encoding_element(std::string::iterator begin, std::string::iterator end);
    std::string::iterator parse_expect_element(std::string::iterator begin, std::string::iterator end);
    std::string::iterator parse_connection_element(std::string::iterator begin, std::string::iterator end);

    void parse_list(
        std::string::iterator token_start, 
        std::string::iterator token_end, 
        std::string::iterator (RequestParser::*element_parser)(std::string::iterator token_start, std::string::iterator token_end)
    );
};
=== ./inc/HTTPRequestBuffer.hpp ===
#pragma once

#include <stdint.h>
#include <string>
#include <stdexcept>
#include <cstring>
#include <iostream>
#include "ReadNetBuffer.hpp"

class HTTPRequestBuffer : public ReadNetBuffer
{
public:
    HTTPRequestBuffer();
    ~HTTPRequestBuffer();

    void new_request();
    bool get_crlf_line(uint8_t * & _begin, uint8_t * & _end);
    bool get_chunk(ssize_t size, uint8_t * & _begin, uint8_t * & _end);

    bool get_crlf_line(std::string::iterator & _begin, std::string::iterator &  _end);
    bool get_chunk(ssize_t size, std::string::iterator &  _begin, std::string::iterator &  _end);

    ssize_t previous_read_size() const;

private:
    HTTPRequestBuffer(HTTPRequestBuffer &);
    HTTPRequestBuffer & operator=(HTTPRequestBuffer &);
    ssize_t _offset;
    ssize_t _last_read_size;
};
=== ./inc/SysBuffer.hpp ===
#pragma once

#include <stdint.h>
#include <sys/types.h>


class SysBuffer 
{
public:
    SysBuffer(int fd):_fd(fd){}
    
    virtual ~SysBuffer(){};
    virtual ssize_t read(uint8_t *buff, size_t size) = 0;
    virtual ssize_t write(uint8_t *buff, size_t size) = 0;

    int _fd;
};
=== ./inc/ServerValidator.hpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerValidator.hpp                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/29 18:57:14 by irozhkov          #+#    #+#             */
/*   Updated: 2025/06/04 19:56:04 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVERVALIDATOR_HPP
# define SERVERVALIDATOR_HPP

# pragma once

# include <iostream>
# include <map>
# include <set>
# include <string>
# include <vector>

# include "Parsed.hpp"
# include "Utils.hpp"

struct ListenKey
{
	std::string	host;
	int			port;

	bool operator<(const ListenKey& other)  const
	{
		if (host != other.host)
			return (host < other.host);

		return (port < other.port);
	}
};

class ServerValidator
{
	public:
		static void validate(const std::vector<ParsedServer>& servers);
};

#endif

=== ./inc/ConfigInheritance.hpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigInheritance.hpp                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: irozhkov <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/16 16:42:00 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 19:59:02 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONFIGINHERITANCE_HPP
# define CONFIGINHERITANCE_HPP

# include "Parsed.hpp"

void	applyAutoindex(ParsedServer& server);
void	applyAllowMethods(ParsedServer& server);

#endif

=== ./inc/ServerConfig.hpp ===
#ifndef SERVERCONFIG_HPP
#define SERVERCONFIG_HPP

#include <string>
#include <vector>
#include <map>
#include "Location.hpp"
#include "Parsed.hpp"
#include "Enums.hpp"

struct ServerConfig {
    std::vector<std::string>        server_names;
    std::string                     root;
    std::vector<std::string>        index_files;
    std::map<int, std::string>      error_pages;
    std::vector<std::string>        allow_methods;
    AutoIndexState                  autoindex;
    size_t                          client_max_body_size;
    std::map<std::string, Location> locations;
    bool                            allow_upload;

    ServerConfig();
    ServerConfig(const ParsedServer& parsed);
    ServerConfig(const ServerConfig& other);
    ServerConfig& operator=(const ServerConfig& other);

    bool matchesServerName(const std::string& hostname) const;
    Location* findLocation(const std::string& path, bool resolve_index = true) const;
    bool isMethodAllowed(const std::string& method) const;
    bool getAutoindex() const;
    AutoIndexState getAutoindex(const Location* location) const;
    std::string getClientMaxBodySizeString() const;
    std::string getDebugInfo() const;

    const std::vector<std::string>& getServerNames() const { return server_names; }

    const std::string& getRoot() const { return root; }

    const std::vector<std::string>& getIndexFiles() const { return index_files; }

    std::string getErrorPage(int error_code, const Location* location = NULL) const;

    const std::vector<std::string>& getAllowMethods() const { return allow_methods; }
    const std::vector<std::string>& getAllowMethods(const Location* location) const;

    size_t getClientMaxBodySize() const { return client_max_body_size; }

    const std::map<std::string, Location>& getLocations() const;
    
    bool getAllowUpload() const { return allow_upload; }

    std::string getServerNamesString() const;
    bool isDefaultServer() const;

private:
    size_t parseBodySize(const std::string& size_str) const;
    Location* resolveIndexAndRematch(const std::string& path, Location* original_location) const;
};

std::ostream& operator<<(std::ostream& os, const ServerConfig& config);

#endif
=== ./inc/ResponseManager.hpp ===
#pragma once

#include <stdexcept>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <cstdio>
#include "HTTPRequest.hpp"
#include "HTTPError.hpp"
#include "SysBufferFactory.hpp"
#include "HTTPResponseBuffer.hpp"
#include "File.hpp"
#include "ActiveFileDescriptor.hpp"

// FORWARD DECLARATIONS TO AVOID CIRCULAR DEPENDENCIES
class ServerConfig;
class Location;

class ResponseManager
{
public:
    enum RM_status {
        WAITING_REQUEST, READING_FILE, WRITING_FILE, WRITING_RESPONSE, ERROR, DONE
    };

    ResponseManager(HTTPRequest &, HTTPError &, SysBufferFactory::sys_buffer_type type, int fd);
    ~ResponseManager();

    void set_virtual_server(ServerConfig const * config); 
    void set_location(Location const * location);
    void generate_response();
    // void generate_response(CGIResponse & response);
    void process();
    bool response_done();

    void reset();
    ActiveFileDescriptor get_active_file_descriptor();
    RM_status get_status() const { return _status; }

private:
    static const size_t _WRITE_BUFFER_SIZE = 2000;
    static const size_t _READ_FILE_BUFFER_SIZE = 2000;
    static const size_t _WRITE_FILE_BUFFER_SIZE = 2000;

    HTTPRequest & _request;
    HTTPError & _error;    
    RM_status _status;
    ServerConfig const * _server; 
    Location const * _location;
    SysBuffer * _sys_buffer;
    HTTPResponseBuffer _buffer;
    File _file;
    std::string::iterator _wr_file_it;


    void generate_status_response();
    std::string generate_default_error_html();
    void generate_get_response();
    void generate_post_response();
    void generate_delete_response();

    void read_file();
    void write_file();
    void write_response();
    void read_directory();
    void prepare_file_reading();
    void prepare_file_writing();
    void new_response();
    bool validate_method();

    std::string const get_host_path();
    std::vector<HTTPMethod> get_allowed_methods();
    bool allow_upload();
    bool is_autoindex();
    
    // How does upload_dir work
    // Return ?
};
=== ./inc/ActiveFileDescriptor.hpp ===
#pragma once

struct ActiveFileDescriptor {
    ActiveFileDescriptor(int fd, int mode): fd(fd), mode(mode){};
    int fd;
    int mode;
};
=== ./inc/DebugView.hpp ===
#pragma once

#include <string>
#include <vector>
#include "Parsed.hpp"
#include "Logger.hpp"

class VirtualServersManager;

class DebugView {
public:
    static void printConfigSummary(const ParsedServers &configs);
    static void printBox(const std::string &title, const std::vector<std::string> &lines);
};



=== ./inc/ReadNetBuffer.hpp ===
#pragma once

#include <stdint.h>
#include <string>
#include <stdexcept>
#include <cstring>
#include <sys/types.h>

class ReadNetBuffer
{
public:
    ReadNetBuffer();
    ~ReadNetBuffer();

    void append(uint8_t const * str, ssize_t size);
    void append(std::string const & str);
    void expand(size_t min_size);
    void clear();
    void shrink();
    void reserve(ssize_t n);
    void consume_bytes(ssize_t n);

    ssize_t capacity() const;
    ssize_t size() const;

    std::string::iterator begin();
    std::string::iterator end();
    std::string::const_iterator cbegin() const;
    std::string::const_iterator cend() const;

    uint8_t * itbegin();
    uint8_t * itend();
    uint8_t const * citbegin() const;
    uint8_t const * citend() const;


    uint8_t * get_start();

protected:
    void discard_current();
    void manual_increase(size_t n);

private:
    static const size_t START_BUFFER_SIZE;
    static const size_t SHRINK_BUFFER_SIZE;

    ReadNetBuffer(ReadNetBuffer &);
    ReadNetBuffer & operator=(ReadNetBuffer &);

    
    uint8_t *_buffer;
    uint8_t *_start;
    uint8_t *_end;
    uint8_t *_tail;
};
=== ./inc/HTTPBody.hpp ===
#pragma once

#include "HTTPElement.hpp"
#include "URI.hpp"
#include "HTTPMethod.hpp"

struct HTTPBody : public HTTPElement 
{
    std::string content;

    HTTPBody();
    void reset();
    void print(std::ostream & os) const;
};

std::ostream & operator<<(std::ostream & os,  HTTPBody const & line);
=== ./inc/Utils.hpp ===
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Utils.hpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mvisca-g <mvisca-g@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/30 13:51:01 by irozhkov          #+#    #+#             */
/*   Updated: 2025/08/16 13:35:56 by irozhkov         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef UTILS_HPP
# define UTILS_HPP

# pragma once

# include <arpa/inet.h>
# include <cstring>
# include <fstream>
# include <ifaddrs.h>
# include <iostream>
# include <map>
# include <netinet/in.h>
# include <sstream>
# include <stdexcept>
# include <string>
# include <sys/socket.h>
# include <unistd.h>
# include <vector>

// Forward declarations para evitar dependencias circulares
class Location;
struct ParsedServer;
# include "StringUtil.hpp"

# define CODE_ERR(str) (throw std::runtime_error(std::string(str) + " at " + __FILE__ + ":" + wss::i_to_dec(__LINE__)))

enum ParsingMessageType {
    DEFAULT_SERVER,
    LOCAL_HOST,
    ASTERIKS_HOST
};

/* Check input file function */
int checkFile(const char* argv);

/* Function for getting real localhost */
std::string getLoopbackAddress();

/* Functions for printing */
void printLocationConfig(const Location& loc);
void printServerConfig(const ParsedServer& config);
void printParsingMessage(ParsingMessageType type);

/* Convert into a logs entry */
void OKlogsEntry(const std::string& title, const std::string& str);
void ERRORlogsEntry(const std::string& title, const std::string& str);

#endif

=== ./inc/StringUtil.hpp ===
#pragma once

#include <string>
#include <stdexcept>
#include <cstring>
#include <algorithm>
#include "ParsingUtil.hpp"

namespace wss 
{
    void to_upper(std::string &);
    void to_lower(std::string &);
    void trim(std::string &);
    bool str_equal(std::string::iterator it, size_t n, const char *s);
    bool str_equal(std::string::iterator it, const char *s);
    bool casecmp(std::string const & s1, std::string const & s2);
    bool casecmp(std::string const & s1, size_t pos, size_t len, std::string const & s2);

    std::string i_to_hex(size_t size);
    std::string ui_to_dec(ssize_t size);
    std::string i_to_dec(size_t size);

    void remove_uri_segment(std::string & out);
    std::string::iterator move_uri_segment(std::string & dst, std::string & src, std::string::iterator begin);

    std::string::iterator skip_ascii_whitespace(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_uri_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_http_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_protocol_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_absolute_path(std::string::iterator begin, std::string::iterator end); // Any / and segments
    std::string::iterator skip_host_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_port_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_path_rootless(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_query_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_fragment_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_schema_token(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_ascii_whitespace_r(std::string::iterator end, std::string::iterator begin);
    std::string::iterator skip_until(std::string::iterator begin, std::string::iterator end, std::string const & str);
    std::string::iterator skip_until_dquoted_string_end(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_whitespace(std::string::iterator begin, std::string::iterator end);
    std::string::iterator skip_hexa_token(std::string::iterator begin, std::string::iterator end);

}


=== ./inc/Logger.hpp ===
#pragma once

#include <stdexcept>
#include <string>
#include <iostream>
#include <fstream>
#include <ctime>
#include <cstring>

struct HTTPRequest;

enum LogLevel 
{
    DEBUG, INFORMATION, WARNING, ERROR
};

class Logger
{
public:
    static const std::string RED;
    static const std::string GREEN;
    static const std::string YELLOW;
    static const std::string BLUE;
    static const std::string RESET;

    Logger(LogLevel log_level);
    ~Logger();

    static Logger & getInstance();

    void info(std::string const & str) const;
    void error(std::string const & str) const;
    void warning(std::string const & str) const;

    void setLogLevel(LogLevel log_level);

    void setOutput(LogLevel log_level, std::string const & str);
    void setOutput(LogLevel log_level, std::ostream & out);


    std::ostream & operator<<(std::string const & str);
    std::ostream & operator<<(HTTPRequest const & header);

private:
    static const std::string ERR_PREFIX;
    static const std::string WAR_PREFIX;
    static const std::string INFO_PREFIX;
    static const std::string DEBUG_PREFIX;

    LogLevel _log_level; 
    std::ostream * _information_output;
    std::ostream * _warning_output;
    std::ostream * _error_output;

    void _output_timestamp(std::ostream * os) const;

    Logger(Logger &);
    Logger & operator=(Logger &);
};


=== ./inc/SocketInfo.hpp ===
#ifndef SOCKETINFO_HPP
#define SOCKETINFO_HPP

#include "VirtualServersManager.hpp"
#include "Connection.hpp"

enum SocketType {
	LISTEN_SOCKET,
	CLIENT_SOCKET
};

struct SocketInfo {
	SocketType					type;
	Listen::VirtualServerKey	listen_key;
	Connection*					connection;
	
	SocketInfo(const Listen::VirtualServerKey& key) 
		: type(LISTEN_SOCKET)
		, listen_key(key)
		, connection(NULL) {
	}
	
	SocketInfo(Connection* conn) 
		: type(CLIENT_SOCKET)
		, listen_key("", 0)
		, connection(conn) {
	}
};

#endif
=== ./inc/MediaType.hpp ===
#pragma once

#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Logger.hpp"
#include "StringUtil.hpp"

struct MediaType;

typedef std::vector<std::pair<MediaType, std::vector<std::string> > > t_mime_conf;

struct MediaType 
{
    static t_mime_conf ACCEPTED_TYPES;
    static const std::string TYPES_PATH;
    static void load_types();

    MediaType();
    MediaType(std::string type, std::string subtype);
    std::string type;
    std::string subtype;
    std::vector<std::pair<std::string, std::string> > parameters;

    static std::string filename_to_type(std::string const & filename);

    void reset();
};

std::ostream & operator<<(std::ostream & os,  MediaType const & header);
=== ./inc/VirtualServersManager.hpp ===
#ifndef VIRTUAL_SERVERS_MANAGER_HPP
#define VIRTUAL_SERVERS_MANAGER_HPP

#include "ServerConfig.hpp"
#include "HTTPRequest.hpp"
#include "RequestManager.hpp"
#include "HTTPError.hpp"
#include "ElementParser.hpp"
#include "SysBufferFactory.hpp"
#include "ResponseManager.hpp"
#include "Location.hpp"
#include "HTTPMethod.hpp"
#include "Status.hpp"
#include "Listen.hpp"
#include <vector>
#include <map>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <arpa/inet.h>
#include <stdexcept>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cstring>
#include <sys/epoll.h>

class VirtualServersManager {
public:
    // Estructura para manejar el estado de los clientes
    struct ClientState {

        public:

            enum Status {
                READING_REQUEST,
                PROCESSING_REQUEST,
                ERROR_HANDLING,
                WRITING_RESPONSE,
                WAITING_FILE,
                WAITING_CGI,
                CLOSING,
                CLOSED
            };

            int             client_fd;
            HTTPRequest     request;
            HTTPError       error;
            ElementParser   element_parser;
            RequestManager  request_manager;
            ResponseManager response_manager;
            Status          status;
            int             error_retry_count;
            HTTPRequest     original_request;

            ClientState(int client_fd);

            bool isRequestComplete() const;
            bool hasError() const;
        
            static std::map<int, ClientState*> client_states;
            static ClientState* getOrCreateClientState(int client_fd);
            static void cleanupClientState(int client_fd);
            void changeStatus(Status new_status, const std::string& reason = "");
            
        private:
            std::string statusToString(Status status);
    };

    struct ListenSocket {
        int socket_fd;
        Listen listen_config;
        std::vector<ServerConfig*> virtual_hosts;
        
        ListenSocket();
        ListenSocket(const Listen& config);
    };

private:
    std::vector<ServerConfig>                       _server_configs;      // Todas las configuraciones
    std::map<Listen, ListenSocket>                  _listen_sockets;      // Socket único por host:port
    std::map<Listen, std::vector<ServerConfig*> >   _virtual_hosts;       // Virtual hosts por listen
    int                                             _epoll_fd;
    std::vector<struct epoll_event>                 _events;
    std::vector<int>                                _client_fds;
    std::map<int, ListenSocket*>                    _client_to_listen_socket;

    // Métodos privados de socket management
    void setupEpoll();
    void createListenSockets();
    void setupListenSocket(ListenSocket& listen_socket);
    void bindListenSocket(ListenSocket& listen_socket);
    
    // Métodos de búsqueda
    bool isListenSocket(int fd) const;
    ListenSocket* findListenSocket(int fd);
    
    // Event handling
    void handleEvent(const struct epoll_event& event);
    void handleNewConnection(ListenSocket* listen_socket);
    void handleClientData(int client_fd);

    void handleReadingRequest(int client_fd, ClientState* client);
    void handleProcessingRequest(int client_fd, ClientState* client);
    void handleErrorHandling(int client_fd, ClientState* client);
    void handleWritingResponse(int client_fd, ClientState* client);
    void handleWaitingFile(int client_fd, ClientState* client);
    void handleWaitingCGI(int client_fd, ClientState* client);
    void handleClosing(int client_fd, ClientState* client);
    void handleClosed(int client_fd, ClientState* client);

    // Métodos aux de error
    bool attemptErrorPageRewrite(int client_fd, ClientState* client);

    // Cierre de fd - desconexion
    void disconnectClient(int client_fd);

    // Status handlling
    std::string statusToString(Status status);
    
    // Request processing
    void processCompleteRequest(int client_fd, HTTPRequest& request);
    ServerConfig* findServerConfigForRequest(const HTTPRequest& request, ListenSocket* listen_socket);
    bool isMethodAllowed(const ServerConfig* server_config, const Location* location, HTTPMethod method);
    
    // Response handling
    void sendErrorResponse(int client_fd, int status_code, const std::string& message);
    void sendErrorResponse(int client_fd, const HTTPError& error);
    
    // Virtual hosts auxiliares
    bool matchesServerName(const ServerConfig* config, const std::string& host) const;
    ServerConfig* getDefaultServerConfig(ListenSocket* listen_socket) const;
    
    // CGI y static content
    bool isCgiRequest(const Location* location, const std::string& path);
    void processCgiRequest(int client_fd, HTTPRequest& request, const Location* location);
    void processStaticRequest(int client_fd, const ServerConfig* server_config, const Location* location);

public:
    VirtualServersManager();
    VirtualServersManager(const ParsedServers& configs);
    ~VirtualServersManager();
    
    void run();
    
    // Debug/información
    void printVirtualHostsInfo() const;
    void printListenSocketsInfo() const;

    static const int MAX_ERROR_RETRIES = 1;
};

#endif
=== ./inc/SysBufferFactory.hpp ===
#pragma once

#include <stdexcept>
#include "SysBuffer.hpp"
#include "SysNetBuffer.hpp"
#include "SysFileBuffer.hpp"

class SysBufferFactory 
{
public:
    enum sys_buffer_type {SYSBUFF_FILE, SYSBUFF_SOCKET};
    static SysBuffer * get_buffer(sys_buffer_type type, int fd);
    
private:
    SysBufferFactory();
};

=== ./inc/Location.hpp ===
#ifndef LOCATION_HPP
#define LOCATION_HPP

#include "Enums.hpp"
#include "HTTPRequest.hpp"
#include <string>
#include <vector>
#include <map>

// TODO: La clase Location no está terminada - falta implementar:
// - Validación completa de configuración
// - Manejo de herencia de configuración desde el server padre
// - Implementación completa de CGI configuration
// - CRITICAL: Manejo de exact match vs prefix match en locations:
//   * location = /     -> exact match para "/"
//   * location /       -> prefix match para todo lo que empiece con "/"
//   * Si request es "/index.html" y existe "location = /" con "index index.html"
//     debe hacer redirect INTERNO (no 301) para usar la location exacta
//   * El match maker debe resolver esto internamente sin informar al cliente
//   * Necesita re-matching automático cuando se resuelve un index file
class Location {
public:
	enum MatchType { EXACT, PREFIX };

private:
	std::string								_path;
	MatchType								_match_type;
	std::vector<std::string>				_methods;
	std::string								_root;
	std::string								_index;
	AutoIndexState							_autoindex; // que llegue heredado ya y que  no haga falta mirar server
	std::string                             _redirect;
	std::string 							_cgi_extension;
	bool									_allow_upload; // mirar el constructor que todo pase de parseo de location al objeto
	std::map<int, std::string> 				_error_pages;

public:
	Location();
	Location(const Location& other);
	~Location();

	bool matchesPath(const std::string& path) const;

	const std::string& getPath() const { return _path; }

	const MatchType& getMatchType() const { return _match_type; }

	const std::string& getRoot() const { return _root; }

    const std::string& getIndex() const { return _index; }

	AutoIndexState getAutoindex() const { return _autoindex; }

    const std::vector<std::string>& getMethods() const { return _methods; }

    const std::string& getRedirect() const { return _redirect; }

    const std::string& getCgiExtension() const { return _cgi_extension; }

	bool getAllowUpload() const { return _allow_upload; }
	
	std::string getErrorPage(int error_code) const;
	
    bool hasAutoindex() const { return _autoindex; }

	void setPath(const std::string& path) { _path = path; }
	void setMatchType(const MatchType& match_type) { _match_type = match_type; }
    void setMethods(const std::vector<std::string>& methods) { _methods = methods; }
    void setRoot(const std::string& root) { _root = root; }
	void setIndex(const std::string& index) { _index = index; }
	void setAutoindex(AutoIndexState state) { _autoindex = state; }
	void setRedirect(const std::string& redirect) { _redirect = redirect; }
	void setCgixtension(const std::string cgi_extension) { _cgi_extension = cgi_extension; }
	void setAllowUpload(const bool allow_upload) { _allow_upload = allow_upload; }
	void setErrorPage(int code, const std::string& path) { _error_pages[code]=path; }
};

#endif

